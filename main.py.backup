import customtkinter
import tkinter as tk
from deep_translator import GoogleTranslator
import pyttsx3
import threading
from pypinyin import pinyin, lazy_pinyin, Style
from CTkTable import CTkTable
import sys
import os
import time
from concurrent.futures import ThreadPoolExecutor
import queue
import gc
import psutil
import json
import pickle
from pathlib import Path
import multiprocessing
import tempfile
import webbrowser
try:
    from tkinterweb import HtmlFrame
    HTML_DISPONIBLE = True
    HtmlFrameClass = HtmlFrame
except ImportError:
    HTML_DISPONIBLE = False
    HtmlFrameClass = None
    print("tkinterweb no disponible - usando CTkTable como fallback")

# --- Configuraci√≥n para ejecutable ---
def resource_path(relative_path):
    """Obtener path absoluto del recurso, funciona para dev y para PyInstaller"""
    try:
        # PyInstaller crea una carpeta temporal y almacena el path en _MEIPASS
        # type: ignore - _MEIPASS es creado din√°micamente por PyInstaller
        base_path = sys._MEIPASS  # type: ignore
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

# --- Configuraci√≥n inicial de la apariencia ---
customtkinter.set_appearance_mode("System")
customtkinter.set_default_color_theme("blue")


class GeneradorHTMLPinyin:
    """Generador ultra optimizado de HTML para tabla Pinyin"""
    
    def __init__(self, hardware_info):
        """Inicializa el generador con configuraci√≥n basada en hardware"""
        self.hardware_info = hardware_info
        self.template_cache = {}
        self.css_optimizado = self.generar_css_optimizado()
        self.js_interactivo = self.generar_javascript_interactivo()
    
    def generar_css_optimizado(self):
        """Genera CSS ultra optimizado seg√∫n hardware"""
        # Configuraci√≥n adaptativa seg√∫n hardware
        if self.hardware_info['is_high_end']:
            animations = "transition: all 0.2s ease;"
            effects = "box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
            font_rendering = "text-rendering: optimizeLegibility;"
        elif self.hardware_info['is_low_end']:
            animations = ""  # Sin animaciones para hardware bajo
            effects = ""
            font_rendering = "text-rendering: auto;"
        else:
            animations = "transition: background-color 0.1s ease;"
            effects = "box-shadow: 0 1px 2px rgba(0,0,0,0.05);"
            font_rendering = "text-rendering: optimizeSpeed;"
        
        return f"""
        <style>
            :root {{
                --primary-color: #2563eb;
                --hover-color: #3b82f6;
                --bg-light: #f8fafc;
                --bg-dark: #1e293b;
                --text-light: #1f2937;
                --text-dark: #f1f5f9;
                --border-color: #e2e8f0;
                --pinyin-bg: #eff6ff;
                --chinese-bg: #fefce8;
            }}
            
            * {{
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }}
            
            body {{
                font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
                background: var(--bg-light);
                color: var(--text-light);
                {font_rendering}
                overflow-x: auto;
                padding: 10px;
            }}
            
            @media (prefers-color-scheme: dark) {{
                body {{
                    background: var(--bg-dark);
                    color: var(--text-dark);
                }}
                .pinyin-table {{
                    border-color: #374151;
                }}
                .pinyin-cell {{
                    background: #1f2937;
                }}
                .chinese-cell {{
                    background: #0f172a;
                }}
            }}
            
            .header {{
                background: linear-gradient(135deg, var(--primary-color), var(--hover-color));
                color: white;
                border-radius: 12px;
                padding: 16px 20px;
                margin-bottom: 16px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 12px;
                box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2);
            }}
            
            .header-content {{
                flex: 1;
                text-align: left;
            }}
            
            .title {{
                font-size: 24px;
                font-weight: 700;
                margin-bottom: 4px;
                text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            }}
            
            .subtitle {{
                font-size: 14px;
                opacity: 0.9;
                font-weight: 400;
            }}
            
            .header-stats {{
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }}
            
            .stat-badge {{
                background: rgba(255,255,255,0.2);
                padding: 4px 8px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 500;
                backdrop-filter: blur(10px);
            }}
            
            .controls-panel {{
                background: white;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 16px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                display: flex;
                gap: 16px;
                align-items: center;
                flex-wrap: wrap;
                justify-content: space-between;
            }}
            
            .search-section {{
                flex: 1;
                min-width: 300px;
            }}
            
            .input-group {{
                display: flex;
                gap: 8px;
                align-items: center;
            }}
            
            .search-input {{
                flex: 1;
                padding: 12px 16px;
                border: 2px solid var(--border-color);
                border-radius: 8px;
                font-size: 14px;
                outline: none;
                transition: all 0.2s ease;
                background: #fafafa;
            }}
            
            .search-input:focus {{
                border-color: var(--primary-color);
                background: white;
                box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
                transform: translateY(-1px);
            }}
            
            .action-section {{
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }}
            
            .btn {{
                padding: 10px 16px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                white-space: nowrap;
                {animations}
            }}
            
            .btn-copy {{
                background: var(--primary-color);
                color: white;
                {effects}
            }}
            
            .btn-copy:hover {{
                background: var(--hover-color);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(37, 99, 235, 0.3);
            }}
            
            .btn-clear {{
                background: #6b7280;
                color: white;
            }}
            
            .btn-clear:hover {{
                background: #4b5563;
                transform: translateY(-1px);
            }}
            
            .btn-info {{
                background: #f59e0b;
                color: white;
            }}
            
            .btn-info:hover {{
                background: #d97706;
                transform: translateY(-1px);
            }}
            
            .btn:active {{
                transform: translateY(0);
            }}
            
            .copy-btn {{
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 12px 24px;
                font-size: 16px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                display: inline-flex;
                align-items: center;
                gap: 8px;
                margin-left: 16px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }}
            
            .copy-btn:hover {{
                background: linear-gradient(135deg, #059669, #047857);
                transform: translateY(-3px);
                box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
            }}
            
            .copy-btn:active {{
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
            }}
            
            .header {{
                background: linear-gradient(135deg, var(--primary-color), var(--hover-color));
                color: white;
                border-radius: 16px;
                padding: 20px 24px;
                margin-bottom: 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 16px;
                box-shadow: 0 6px 20px rgba(37, 99, 235, 0.25);
            }}
            
            .header h1 {{
                font-size: 28px;
                font-weight: 800;
                margin: 0;
                color: #1f2937;
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }}
            
            .subtitle {{
                display: flex;
                align-items: center;
                gap: 16px;
                font-size: 14px;
                opacity: 0.95;
                flex-wrap: wrap;
            }}
                margin-bottom: 20px;
                {effects}
            }}
            
            .controls {{
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                flex-wrap: wrap;
                gap: 10px;
            }}
            
            .btn {{
                padding: 8px 16px;
                background: var(--primary-color);
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                {animations}
            }}
            
            .btn:hover {{
                background: var(--hover-color);
                transform: translateY(-1px);
            }}
            
            .search-box {{
                padding: 8px 12px;
                border: 2px solid var(--border-color);
                border-radius: 6px;
                font-size: 14px;
                {animations}
            }}
            
            .search-box:focus {{
                outline: none;
                border-color: var(--primary-color);
                {effects}
            }}
            
            .pinyin-container {{
                max-height: 600px;
                overflow-y: auto;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                background: white;
                {effects}
            }}
            
            .pinyin-table {{
                width: 100%;
                border-collapse: collapse;
                font-size: 16px;
            }}
            
            .pinyin-row {{
                {animations}
            }}
            
            .pinyin-row:hover {{
                background: var(--pinyin-bg);
            }}
            
            .pinyin-cell, .chinese-cell {{
                padding: 8px 6px;
                text-align: center;
                border: 1px solid var(--border-color);
                min-width: 50px;
                position: relative;
                transition: all 0.2s ease;
            }}
            
            .pinyin-cell {{
                background: var(--pinyin-bg);
                color: var(--primary-color);
                font-weight: 600;
                font-size: 13px;
                border-bottom: 2px solid var(--primary-color);
                border-radius: 6px 6px 0 0;
            }}
            
            .chinese-cell {{
                background: var(--chinese-bg);
                font-size: 18px;
                font-weight: 700;
                color: #1f2937;
                border-top: none;
                border-radius: 0 0 6px 6px;
                padding: 10px 6px;
            }}
            
            .pinyin-row + .chinese-row {{
                margin-top: -1px; /* Eliminar separaci√≥n entre pinyin y caracteres */
            }}
            
            .separator-row {{
                height: 6px;
                background: linear-gradient(90deg, 
                    transparent 0%, 
                    var(--border-color) 20%, 
                    var(--border-color) 80%, 
                    transparent 100%);
            }}
            
            .separator-row td {{
                padding: 2px !important;
                font-size: 12px !important;
                color: #94a3b8 !important;
            }}
            
            .highlight {{
                background: #fef3c7 !important;
                border: 2px solid #f59e0b !important;
                {animations}
            }}
            
            .copy-notification {{
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 1000;
                {animations}
                {effects}
            }}
            
            .stats {{
                margin-top: 15px;
                padding: 10px;
                background: var(--bg-light);
                border-radius: 6px;
                text-align: center;
                font-size: 13px;
                color: #6b7280;
            }}
            
            /* Responsive Design */
            @media (max-width: 768px) {{
                .pinyin-cell, .chinese-cell {{
                    padding: 8px 4px;
                    font-size: 14px;
                    min-width: 40px;
                }}
                
                .header {{
                    padding: 10px;
                    font-size: 18px;
                }}
                
                .controls {{
                    flex-direction: column;
                    align-items: stretch;
                }}
                
                .btn {{
                    width: 100%;
                    margin: 2px 0;
                }}
            }}
            
            /* Optimizaci√≥n para hardware bajo */
            @media (max-width: 600px) {{
                .pinyin-table {{
                    font-size: 13px;
                }}
                
                .pinyin-cell, .chinese-cell {{
                    padding: 6px 3px;
                }}
            }}
            
            /* Scroll personalizado */
            .pinyin-container::-webkit-scrollbar {{
                width: 8px;
            }}
            
            .pinyin-container::-webkit-scrollbar-track {{
                background: #f1f1f1;
                border-radius: 4px;
            }}
            
            .pinyin-container::-webkit-scrollbar-thumb {{
                background: var(--primary-color);
                border-radius: 4px;
            }}
            
            .pinyin-container::-webkit-scrollbar-thumb:hover {{
                background: var(--hover-color);
            }}
            
            /* Estilos para las filas de traducci√≥n individuales */
            .translation-row {{
                background: transparent;
            }}
            
            .translation-cell {{
                padding: 0 !important;
                border: none !important;
            }}
            
            .translation-content {{
                background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
                margin: 8px 4px 12px 4px;
                padding: 12px 16px;
                border-radius: 8px;
                border-left: 4px solid var(--primary-color);
                font-size: 1em;
                line-height: 1.5;
                color: #1f2937;
                box-shadow: 0 2px 4px rgba(37, 99, 235, 0.1);
                font-weight: 500;
                text-align: left;
            }}
            
            /* Responsive para las traducciones individuales */
            @media (max-width: 768px) {{
                .translation-content {{
                    font-size: 0.9em;
                    padding: 10px 12px;
                    margin: 6px 2px 10px 2px;
                }}
            }}
        </style>
        """
    
    def generar_javascript_interactivo(self, contenido_completo=None):
        """Genera JavaScript simplificado solo para actualizar traducci√≥n"""
        
        return """
        <script>
            // Script simplificado - solo para funcionalidades b√°sicas
            document.addEventListener('DOMContentLoaded', () => {
                console.log('Tabla Pinyin cargada correctamente');
            });
        </script>
        """

    def generar_html_optimizado(self, datos_tabla, titulo="Pronunciaci√≥n Pinyin", contenido_completo=None):
        """Genera HTML ultra optimizado para la tabla Pinyin con contenido completo"""
        if not datos_tabla:
            return self.generar_html_vacio()
        
        # Estad√≠sticas
        total_filas = len(datos_tabla)
        caracteres_chinos = sum(1 for fila in datos_tabla for celda in fila 
                              if isinstance(celda, str) and any('\u4e00' <= c <= '\u9fff' for c in celda))
        
        # Generar filas de tabla optimizadas con orden correcto
        filas_html = []
        i = 0
        
        while i < len(datos_tabla):
            fila_actual = datos_tabla[i]
            
            # Verificar si es una fila separadora vac√≠a
            if not fila_actual or all(not str(celda).strip() for celda in fila_actual):
                # Fila separadora m√°s compacta
                filas_html.append('<tr class="separator-row"><td colspan="100%" style="text-align: center; padding: 4px; color: #94a3b8; font-size: 14px;">‚≠ê</td></tr>')
                i += 1
                continue
            
            # Procesar par de filas (pinyin + caracteres)
            fila_pinyin = []
            fila_caracteres = []
            
            # Primera fila (deber√≠a ser pinyin)
            for celda in fila_actual:
                celda_str = str(celda).strip()
                if celda_str:
                    fila_pinyin.append(f'<td class="pinyin-cell">{celda_str}</td>')
            
            # Segunda fila (deber√≠a ser caracteres chinos)
            if i + 1 < len(datos_tabla):
                fila_siguiente = datos_tabla[i + 1]
                for celda in fila_siguiente:
                    celda_str = str(celda).strip()
                    if celda_str:
                        fila_caracteres.append(f'<td class="chinese-cell">{celda_str}</td>')
                i += 2  # Saltar ambas filas
            else:
                i += 1  # Solo una fila
            
            # Agregar filas en orden correcto: PINYIN ARRIBA, CARACTERES ABAJO
            if fila_pinyin:
                filas_html.append(f'<tr class="pinyin-row">{"".join(fila_pinyin)}</tr>')
            if fila_caracteres:
                filas_html.append(f'<tr class="chinese-row">{"".join(fila_caracteres)}</tr>')
                
                # Agregar fila de traducci√≥n para este grupo individual
                if fila_caracteres:
                    # Extraer solo los caracteres chinos de este grupo
                    caracteres_grupo = []
                    if i + 1 < len(datos_tabla):
                        fila_siguiente = datos_tabla[i + 1]
                        for celda in fila_siguiente:
                            celda_str = str(celda).strip()
                            if celda_str and celda_str != "‚≠ê":
                                caracteres_grupo.append(celda_str)
                    
                    if caracteres_grupo:
                        texto_grupo = "".join(caracteres_grupo)
                        try:
                            # Traducir solo este grupo espec√≠fico
                            from deep_translator import GoogleTranslator
                            traductor_grupo = GoogleTranslator(source='zh', target='es')
                            traduccion_grupo = traductor_grupo.translate(texto_grupo)
                        except:
                            traduccion_grupo = "Traducci√≥n no disponible"
                        
                        filas_html.append(f'''
                        <tr class="translation-row">
                            <td colspan="100%" class="translation-cell">
                                <div class="translation-content">
                                    üåê {traduccion_grupo}
                                </div>
                            </td>
                        </tr>
                        ''')
            
            # Agregar espaciado m√≠nimo entre grupos
            if i < len(datos_tabla):
                filas_html.append('<tr style="height: 8px;"><td colspan="100%"></td></tr>')
        
        # Combinar todo el HTML
        css = self.generar_css_optimizado()
        js = self.generar_javascript_interactivo(contenido_completo)
        
        html_content = f"""
        <!DOCTYPE html>
        <html lang="es">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{titulo}</title>
            {css}
        </head>
        <body>
            <div class="container">
                <header class="header">
                    <h1>{titulo}</h1>
                    <div class="subtitle">
                        üìä {total_filas} grupos ‚Ä¢ üÄÑ {caracteres_chinos} caracteres chinos
                    </div>
                </header>
                
                <div class="table-container">
                    <table class="pinyin-table">
                        {"".join(filas_html)}
                    </table>
                </div>
            </div>
            {js}
        </body>
        </html>
        """
        
        return html_content

    def generar_html_vacio(self):
        """Genera HTML para estado vac√≠o"""
        return f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Pinyin - Listo</title>
            {self.css_optimizado}
        </head>
        <body>
            <div class="header">
                <h1>üéå Pronunciaci√≥n Pinyin ‚ö°</h1>
                <p>Ingresa texto chino para ver la pronunciaci√≥n</p>
            </div>
            
            <div style="text-align: center; padding: 50px; color: #6b7280;">
                <div style="font-size: 48px; margin-bottom: 20px;">üà≥</div>
                <h2>Listo para mostrar Pinyin</h2>
                <p>La tabla aparecer√° aqu√≠ cuando traduzcas texto chino</p>
                <p style="margin-top: 20px; font-size: 14px;">
                    ‚ö° HTML ultra optimizado ‚Ä¢ üöÄ Renderizado instant√°neo ‚Ä¢ üì± Totalmente responsive
                </p>
            </div>
            {self.js_interactivo}
        </body>
        </html>
        """

class TraductorChino:
    """Aplicaci√≥n de traductor chino con pronunciaci√≥n Pinyin"""
    
    def __init__(self):
        """Inicializa la aplicaci√≥n del traductor"""
        # Detectar hardware y configurar autom√°ticamente
        self.hardware_info = self.detectar_hardware()
        self.configurar_optimizaciones_hardware()
        
        # Cach√© persistente para traducciones
        self.cache_dir = Path.home() / ".traductor_chino"
        self.cache_dir.mkdir(exist_ok=True)
        self.cache_traducciones = self.cargar_cache("traducciones")
        self.cache_pinyin = self.cargar_cache("pinyin")
        
        # Generador HTML optimizado para hardware
        self.generador_html = GeneradorHTMLPinyin(self.hardware_info)
        self.archivo_html_temp = None
        self.usar_html_viewer = HTML_DISPONIBLE and not self.hardware_info['is_low_end']
        
        # Variables para guardar traducciones actuales
        self.traduccion_actual = ""
        self.pinyin_actual = ""
        self.texto_chino_actual = ""
        
        # Variable para contenido completo (traducci√≥n + pinyin + caracteres)
        self.contenido_completo_actual = {
            'texto_original': '',
            'traduccion': '',
            'datos_pinyin': [],
            'formato_markdown': ''
        }
        
        # Pool de hilos din√°mico optimizado para cualquier CPU
        self.max_workers = self.calcular_workers_optimos()
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)
        self.translation_queue = queue.Queue()
        self.ui_update_queue = queue.Queue()
        
        # Variables de control de progreso optimizadas
        self.progreso_actual = 0
        self.progreso_total = 100
        self.traduccion_en_progreso = False
        self.translation_queue = queue.Queue()
        self.ui_update_queue = queue.Queue()
        
        # Variables de control de progreso optimizadas
        self.progreso_actual = 0
        self.progreso_total = 100
        self.traduccion_en_progreso = False
        
        # Control de optimizaci√≥n de UI (ultra mejorado)
        self.resize_timer = None
        self.ui_bloqueada = False
        self.ultimo_update = time.time()
        self.update_interval = self.calcular_update_interval()
        self.batch_updates = []
        self.update_worker = None
        
        # L√≠mites adaptativos basados en hardware
        self.limite_segmento = self.calcular_limite_segmento()
        self.caracteres_por_lote = self.calcular_caracteres_por_lote()
        
        # Variables para m√©tricas de rendimiento
        self.tiempo_inicio_traduccion = 0
        self.tiempo_ultima_traduccion = time.time()
        self.ultima_gc = time.time()
        
        # Inicializar traductor y motor de voz
        self.translator = GoogleTranslator(source='auto', target='zh-CN')
        self.engine = None
        self.inicializar_motor_voz()
        
        # Crear ventana principal con geometr√≠a adaptativa
        geometria = self.calcular_geometria_inicial()
        self.app = customtkinter.CTk()
        self.app.geometry(geometria)
        self.app.title("Traductor Chino ‚Üí Espa√±ol e Ingl√©s con Pinyin [Optimizado Universal]")
        self.app.resizable(True, True)
        
        # Configurar icono si existe (para .exe)
        try:
            icon_path = resource_path("icon.ico")
            if os.path.exists(icon_path):
                self.app.iconbitmap(icon_path)
        except:
            pass  # Continuar sin icono si no existe
        
        # Configurar tama√±o m√≠nimo adaptativo
        min_size = self.calcular_tama√±o_minimo()
        self.app.minsize(min_size[0], min_size[1])
        
        # Variables para responsividad mejorada
        self.ventana_ancho = int(geometria.split('x')[0])
        self.ventana_alto = int(geometria.split('x')[1])
        self.es_modo_compacto = False
        
        # Configurar grid principal para mejor control del layout
        self.app.grid_columnconfigure(0, weight=1)
        self.app.grid_rowconfigure(0, weight=1)
        
        # Inicializar worker para updates de UI
        self.inicializar_ui_worker()
        
        # Crear la interfaz
        self.crear_interfaz()
        
        # Configurar optimizaci√≥n peri√≥dica adaptativa
        intervalo_optimizacion = self.calcular_intervalo_optimizacion()
        self.app.after(intervalo_optimizacion, self.optimizacion_periodica)
        
        # Configurar eventos de redimensionamiento ultra optimizado
        self.app.bind("<Configure>", self.on_window_resize_ultra_optimizado)
        
        # Guardar cach√© al cerrar
        self.app.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def detectar_hardware(self):
        """Detecta las especificaciones del hardware autom√°ticamente"""
        try:
            info = {
                'cpu_count': multiprocessing.cpu_count(),
                'cpu_freq': psutil.cpu_freq().max if psutil.cpu_freq() else 2400,
                'memory_gb': round(psutil.virtual_memory().total / (1024**3), 1),
                'memory_available_gb': round(psutil.virtual_memory().available / (1024**3), 1),
                'cpu_brand': self.obtener_marca_cpu(),
                'is_low_end': False,
                'is_high_end': False
            }
            
            # Clasificar hardware
            if info['cpu_count'] <= 2 or info['memory_gb'] <= 4:
                info['is_low_end'] = True
            elif info['cpu_count'] >= 8 and info['memory_gb'] >= 16:
                info['is_high_end'] = True
            
            print(f"Hardware detectado: {info['cpu_count']} cores, {info['memory_gb']}GB RAM, {info['cpu_brand']}")
            return info
            
        except Exception as e:
            print(f"Error detectando hardware: {e}")
            # Valores por defecto conservadores
            return {
                'cpu_count': 4,
                'cpu_freq': 2400,
                'memory_gb': 8,
                'memory_available_gb': 6,
                'cpu_brand': 'Unknown',
                'is_low_end': False,
                'is_high_end': False
            }
    
    def obtener_marca_cpu(self):
        """Detecta la marca del CPU (Intel/AMD)"""
        try:
            import platform
            processor = platform.processor().lower()
            if 'intel' in processor:
                return 'Intel'
            elif 'amd' in processor:
                return 'AMD'
            else:
                # M√©todo alternativo usando WMI (Windows)
                try:
                    import subprocess
                    result = subprocess.run(['wmic', 'cpu', 'get', 'name'], 
                                          capture_output=True, text=True, timeout=5)
                    cpu_name = result.stdout.lower()
                    if 'intel' in cpu_name:
                        return 'Intel'
                    elif 'amd' in cpu_name:
                        return 'AMD'
                except:
                    pass
                return 'Unknown'
        except:
            return 'Unknown'
    
    def configurar_optimizaciones_hardware(self):
        """Configura optimizaciones espec√≠ficas seg√∫n el hardware detectado"""
        try:
            hw = self.hardware_info
            
            # Configuraciones espec√≠ficas por marca de CPU
            if hw['cpu_brand'] == 'AMD':
                # AMD suele beneficiarse de m√°s hilos concurrentes
                self.multiplicador_hilos = 1.5
                self.agresividad_cache = 1.2
            elif hw['cpu_brand'] == 'Intel':
                # Intel suele tener mejor single-thread, menos hilos concurrentes
                self.multiplicador_hilos = 1.2
                self.agresividad_cache = 1.0
            else:
                # Configuraci√≥n neutral
                self.multiplicador_hilos = 1.3
                self.agresividad_cache = 1.1
            
            # Ajustes por nivel de hardware
            if hw['is_low_end']:
                self.factor_rendimiento = 0.7
                self.limite_cache_mb = 50
                self.frecuencia_gc = 5000  # GC m√°s frecuente
            elif hw['is_high_end']:
                self.factor_rendimiento = 1.5
                self.limite_cache_mb = 200
                self.frecuencia_gc = 30000  # GC menos frecuente
            else:
                self.factor_rendimiento = 1.0
                self.limite_cache_mb = 100
                self.frecuencia_gc = 15000
            
            print(f"Optimizaciones configuradas para {hw['cpu_brand']} - Factor: {self.factor_rendimiento}")
            
        except Exception as e:
            print(f"Error configurando optimizaciones: {e}")
            # Valores por defecto
            self.multiplicador_hilos = 1.3
            self.agresividad_cache = 1.1
            self.factor_rendimiento = 1.0
            self.limite_cache_mb = 100
            self.frecuencia_gc = 15000
    
    def calcular_workers_optimos(self):
        """Calcula el n√∫mero √≥ptimo de workers basado en el hardware"""
        try:
            hw = self.hardware_info
            base_workers = hw['cpu_count']
            
            # Aplicar multiplicador por marca de CPU
            workers = int(base_workers * self.multiplicador_hilos)
            
            # L√≠mites basados en memoria disponible
            max_workers_por_memoria = max(2, int(hw['memory_available_gb'] / 2))
            workers = min(workers, max_workers_por_memoria)
            
            # L√≠mites absolutos
            workers = max(2, min(workers, 12))  # Entre 2 y 12 workers
            
            print(f"Workers calculados: {workers} (base: {base_workers}, multiplicador: {self.multiplicador_hilos})")
            return workers
            
        except Exception as e:
            print(f"Error calculando workers: {e}")
            return 4  # Valor por defecto seguro
    
    def calcular_update_interval(self):
        """Calcula el intervalo de actualizaci√≥n UI √≥ptimo"""
        try:
            hw = self.hardware_info
            
            # Base: 60 FPS (0.016s) para hardware high-end
            base_interval = 0.016
            
            if hw['is_low_end']:
                return base_interval * 2  # 30 FPS
            elif hw['is_high_end']:
                return base_interval * 0.8  # ~75 FPS
            else:
                return base_interval  # 60 FPS
                
        except:
            return 0.016  # 60 FPS por defecto
    
    def calcular_limite_segmento(self):
        """Calcula el l√≠mite de segmento √≥ptimo para traducci√≥n"""
        try:
            hw = self.hardware_info
            base_limite = 2000
            
            # Ajustar seg√∫n memoria y CPU
            factor = (hw['memory_available_gb'] / 8) * (hw['cpu_count'] / 4)
            factor = max(0.5, min(factor, 2.0))  # Entre 0.5x y 2x
            
            limite = int(base_limite * factor * self.factor_rendimiento)
            return max(1000, min(limite, 4000))  # Entre 1000 y 4000
            
        except:
            return 2000
    
    def calcular_caracteres_por_lote(self):
        """Calcula caracteres por lote para procesamiento Pinyin"""
        try:
            hw = self.hardware_info
            base_chars = 50
            
            if hw['is_high_end']:
                return base_chars * 2  # 100 caracteres
            elif hw['is_low_end']:
                return base_chars // 2  # 25 caracteres
            else:
                return base_chars  # 50 caracteres
                
        except:
            return 50
    
    def calcular_geometria_inicial(self):
        """Calcula la geometr√≠a inicial de ventana seg√∫n el hardware"""
        try:
            hw = self.hardware_info
            
            if hw['is_low_end']:
                return "1200x700"  # M√°s peque√±o para hardware bajo
            elif hw['is_high_end']:
                return "1600x900"  # M√°s grande para hardware alto
            else:
                return "1400x800"  # Tama√±o est√°ndar
                
        except:
            return "1400x800"
    
    def calcular_tama√±o_minimo(self):
        """Calcula el tama√±o m√≠nimo de ventana"""
        try:
            hw = self.hardware_info
            
            if hw['is_low_end']:
                return (800, 450)
            else:
                return (900, 500)
                
        except:
            return (900, 500)
    
    def calcular_intervalo_optimizacion(self):
        """Calcula el intervalo de optimizaci√≥n peri√≥dica"""
        try:
            hw = self.hardware_info
            
            if hw['is_low_end']:
                return 10000  # Cada 10 segundos
            elif hw['is_high_end']:
                return 45000  # Cada 45 segundos
            else:
                return 30000  # Cada 30 segundos
                
        except:
            return 30000
    
    def cargar_cache(self, tipo):
        """Carga cach√© persistente desde disco"""
        try:
            cache_file = self.cache_dir / f"{tipo}_cache.pkl"
            if cache_file.exists():
                with open(cache_file, 'rb') as f:
                    cache_data = pickle.load(f)
                print(f"Cach√© {tipo} cargado: {len(cache_data)} elementos")
                return cache_data
        except Exception as e:
            print(f"Error cargando cach√© {tipo}: {e}")
        
        return {}
    
    def guardar_cache(self, tipo, datos):
        """Guarda cach√© persistente en disco"""
        try:
            cache_file = self.cache_dir / f"{tipo}_cache.pkl"
            with open(cache_file, 'wb') as f:
                pickle.dump(datos, f)
            print(f"Cach√© {tipo} guardado: {len(datos)} elementos")
        except Exception as e:
            print(f"Error guardando cach√© {tipo}: {e}")
    
    def inicializar_ui_worker(self):
        """Inicializa worker dedicado para updates de UI"""
        def ui_update_worker():
            while True:
                try:
                    update_func = self.ui_update_queue.get(timeout=1)
                    if update_func is None:  # Signal to stop
                        break
                    update_func()
                    self.ui_update_queue.task_done()
                except queue.Empty:
                    continue
                except Exception as e:
                    print(f"Error en UI worker: {e}")
        
        self.update_worker = threading.Thread(target=ui_update_worker, daemon=True)
        self.update_worker.start()
    
    def on_closing(self):
        """Maneja el cierre de la aplicaci√≥n guardando cach√©"""
        try:
            # Guardar cach√©s
            self.guardar_cache("traducciones", self.cache_traducciones)
            self.guardar_cache("pinyin", self.cache_pinyin)
            
            # Detener worker de UI
            if hasattr(self, 'ui_update_queue'):
                self.ui_update_queue.put(None)
            
            # Cerrar executor
            if hasattr(self, 'executor'):
                self.executor.shutdown(wait=False)
            
            print("Cach√© guardado y recursos liberados")
            
        except Exception as e:
            print(f"Error cerrando aplicaci√≥n: {e}")
        finally:
            self.app.destroy()
    
    def on_window_resize_ultra_optimizado(self, event):
        """Manejo ultra optimizado de redimensionamiento con m√≠nimo impacto"""
        # Solo procesar eventos de la ventana principal
        if event.widget != self.app:
            return
        
        # Debounce ultra agresivo
        if self.resize_timer:
            self.app.after_cancel(self.resize_timer)
        
        # Delay adaptativo seg√∫n hardware
        delay = 100 if self.hardware_info['is_high_end'] else 200
        self.resize_timer = self.app.after(delay, self.ejecutar_ajuste_ultra_responsive)
    
    def ejecutar_ajuste_ultra_responsive(self):
        """Ejecuta ajuste responsive ultra optimizado"""
        if self.ui_bloqueada:
            return
        
        try:
            self.ui_bloqueada = True
            
            # Obtener dimensiones con verificaci√≥n de cambio significativo
            ancho_actual = self.app.winfo_width()
            alto_actual = self.app.winfo_height()
            
            # Umbral adaptativo seg√∫n hardware
            umbral = 30 if self.hardware_info['is_high_end'] else 50
            
            if (hasattr(self, 'ultimo_ancho') and 
                abs(ancho_actual - self.ultimo_ancho) < umbral and
                abs(alto_actual - self.ultimo_alto) < umbral):
                return
            
            self.ultimo_ancho = ancho_actual
            self.ultimo_alto = alto_actual
            
            # C√°lculo ultra eficiente de par√°metros
            if ancho_actual < 700:
                self.caracteres_por_linea = 4
                font_size = 16
            elif ancho_actual < 1100:
                self.caracteres_por_linea = 6
                font_size = 18
            elif ancho_actual < 1400:
                self.caracteres_por_linea = 8
                font_size = 20
            else:
                self.caracteres_por_linea = 10
                font_size = 22
            
            # Programar updates de manera no bloqueante
            self.programar_update_no_bloqueante(lambda: self.actualizar_fuentes_rapido(font_size))
            self.programar_update_no_bloqueante(lambda: self.actualizar_info_responsive_rapido(ancho_actual))
            
        except Exception as e:
            print(f"Error en ajuste ultra responsive: {e}")
        finally:
            self.ui_bloqueada = False
            self.resize_timer = None
    
    def programar_update_no_bloqueante(self, func):
        """Programa update de UI de manera no bloqueante"""
        try:
            if hasattr(self, 'ui_update_queue'):
                self.ui_update_queue.put(lambda: self.app.after_idle(func))
        except:
            # Fallback a m√©todo directo
            self.app.after_idle(func)
    
    def actualizar_fuentes_rapido(self, font_size):
        """Actualizaci√≥n r√°pida de fuentes con m√≠nimo impacto"""
        try:
            if not hasattr(self, 'ultimo_font_size') or self.ultimo_font_size != font_size:
                self.ultimo_font_size = font_size
                nueva_fuente = ("Arial", font_size)
                
                # Update solo elementos cr√≠ticos
                if hasattr(self, 'texto_entrada'):
                    self.texto_entrada.configure(font=nueva_fuente)
                if hasattr(self, 'texto_traduccion'):
                    self.texto_traduccion.configure(font=nueva_fuente)
        except:
            pass
    
    def actualizar_info_responsive_rapido(self, ancho):
        """Actualizaci√≥n r√°pida de info responsive"""
        try:
            if hasattr(self, 'info_pinyin'):
                if ancho < 700:
                    texto = "üí°"
                elif ancho < 1000:
                    texto = "üí° Pinyin"
                else:
                    texto = "üí° Pronunciaci√≥n disponible"
                
                current_text = self.info_pinyin.cget("text")
                if current_text != texto:
                    self.info_pinyin.configure(text=texto)
        except:
            pass
    
    def inicializar_motor_voz(self):
        """Inicializa el motor de s√≠ntesis de voz con manejo de errores"""
        try:
            self.engine = pyttsx3.init()
            self.configurar_voz()
        except Exception as e:
            print(f"Advertencia: No se pudo inicializar el motor de voz: {e}")
            self.engine = None
    
    def configurar_voz(self):
        """Configura el motor de voz con configuraci√≥n b√°sica"""
        if not self.engine:
            return
        
        try:
            # Configurar solo la velocidad de habla para evitar problemas de tipo
            self.engine.setProperty('rate', 150)
            print("Motor de voz configurado con velocidad est√°ndar")
        except Exception as e:
            print(f"Error configurando motor de voz: {e}")
    
    def crear_interfaz(self):
        """Crea todos los elementos de la interfaz con dise√±o reorganizado"""
        
        # --- Container principal con grid ---
        self.main_container = customtkinter.CTkFrame(self.app)
        self.main_container.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configurar grid del container principal para nueva distribuci√≥n
        self.main_container.grid_columnconfigure(0, weight=1)  # Lado izquierdo (texto y traducci√≥n)
        self.main_container.grid_columnconfigure(1, weight=1)  # Lado derecho (tabla Pinyin)
        self.main_container.grid_rowconfigure(0, weight=0)  # T√≠tulo fijo
        self.main_container.grid_rowconfigure(1, weight=1)  # Contenido principal
        self.main_container.grid_rowconfigure(2, weight=0)  # Barra de progreso
        self.main_container.grid_rowconfigure(3, weight=0)  # Botones fijos
        
        # --- T√≠tulo compacto ---
        titulo = customtkinter.CTkLabel(
            self.main_container,
            text="üà≥ Traductor de Chino üà≥",
            font=("Arial", 26, "bold")  # Letra m√°s grande
        )
        titulo.grid(row=0, column=0, columnspan=2, pady=(10, 15), sticky="ew")
        
        # === LADO IZQUIERDO: Texto y Traducci√≥n ===
        frame_izquierdo = customtkinter.CTkFrame(self.main_container)
        frame_izquierdo.grid(row=1, column=0, sticky="nsew", padx=(5, 2.5), pady=5)
        frame_izquierdo.grid_columnconfigure(0, weight=1)
        frame_izquierdo.grid_rowconfigure(1, weight=1)  # Texto chino
        frame_izquierdo.grid_rowconfigure(3, weight=1)  # Traducci√≥n
        
        # --- Texto en Chino (arriba) ---
        label_entrada = customtkinter.CTkLabel(
            frame_izquierdo,
            text="Texto en Chino:",
            font=("Arial", 18, "bold")  # Letra m√°s grande
        )
        label_entrada.grid(row=0, column=0, pady=(10, 5), sticky="w", padx=10)
        
        self.texto_entrada = customtkinter.CTkTextbox(
            frame_izquierdo,
            height=200,  # M√°s alto
            font=("Arial", 20),  # Letra m√°s grande
            wrap="word"
        )
        self.texto_entrada.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))
        
        # --- Botones para seleccionar idioma ---
        frame_idiomas = customtkinter.CTkFrame(frame_izquierdo)
        frame_idiomas.grid(row=2, column=0, sticky="ew", padx=10, pady=(0, 10))
        frame_idiomas.grid_columnconfigure(0, weight=1)
        frame_idiomas.grid_columnconfigure(1, weight=1)
        
        self.btn_espanol = customtkinter.CTkButton(
            frame_idiomas,
            text="üá™üá∏ Espa√±ol",
            command=self.traducir_a_espanol,
            font=("Arial", 14, "bold"),
            height=35,  # M√°s alto
            corner_radius=8
        )
        self.btn_espanol.grid(row=0, column=0, padx=(0, 5), pady=5, sticky="ew")
        
        self.btn_ingles = customtkinter.CTkButton(
            frame_idiomas,
            text="ÔøΩüá∏ Ingl√©s",
            command=self.traducir_a_ingles,
            font=("Arial", 14, "bold"),
            height=35,  # M√°s alto
            corner_radius=8
        )
        self.btn_ingles.grid(row=0, column=1, padx=(5, 0), pady=5, sticky="ew")
        
        # --- Traducci√≥n (abajo) ---
        label_traduccion = customtkinter.CTkLabel(
            frame_izquierdo,
            text="Traducci√≥n:",
            font=("Arial", 18, "bold")  # Letra m√°s grande
        )
        label_traduccion.grid(row=3, column=0, pady=(0, 5), sticky="w", padx=10)
        
        self.texto_traduccion = customtkinter.CTkTextbox(
            frame_izquierdo,
            height=200,  # M√°s alto
            font=("Arial", 20),  # Letra m√°s grande
            wrap="word"
        )
        self.texto_traduccion.grid(row=4, column=0, sticky="nsew", padx=10, pady=(0, 10))
        
        # === LADO DERECHO: Tabla Pinyin Completa ===
        self.crear_seccion_pinyin_derecha()
        
        # === BARRA DE PROGRESO (entre contenido y botones) ===
        self.crear_barra_progreso()
        
        # --- Botones centrados (AL FINAL) ---
        self.crear_botones_responsive()
    
    def crear_botones_responsive(self):
        """Crea los botones con layout responsive y fuentes m√°s grandes"""
        self.frame_botones = customtkinter.CTkFrame(self.main_container)
        self.frame_botones.grid(row=3, column=0, columnspan=2, sticky="ew", padx=5, pady=10)
        
        # Configurar grid para centrar botones (4 botones ahora)
        for i in range(4):
            self.frame_botones.grid_columnconfigure(i, weight=1)
        
        # Botones con tama√±os optimizados y fuentes m√°s grandes
        self.btn_traducir = customtkinter.CTkButton(
            self.frame_botones,
            text="üà≥ Traducir",
            command=self.traducir_chino_a_espanol,
            font=("Arial", 16, "bold"),  # Fuente m√°s grande
            height=45,  # M√°s alto
            corner_radius=10
        )
        self.btn_traducir.grid(row=0, column=0, padx=5, pady=10, sticky="ew")
        
        self.btn_auto = customtkinter.CTkButton(
            self.frame_botones,
            text="üîÑ Auto",
            command=self.traducir_automatico,
            font=("Arial", 16, "bold"),  # Fuente m√°s grande
            height=45,  # M√°s alto
            corner_radius=10
        )
        self.btn_auto.grid(row=0, column=1, padx=5, pady=10, sticky="ew")
        
        # Bot√≥n de copiar eliminado seg√∫n solicitud del usuario
        
        self.btn_limpiar = customtkinter.CTkButton(
            self.frame_botones,
            text="üóëÔ∏è Limpiar",
            command=self.limpiar_campos,
            font=("Arial", 16, "bold"),  # Fuente m√°s grande
            height=45,  # M√°s alto
            corner_radius=10,
            fg_color="#666666",
            hover_color="#777777"
        )
        self.btn_limpiar.grid(row=0, column=2, padx=5, pady=10, sticky="ew")
    
    def crear_seccion_pinyin_derecha(self):
        """Crea la secci√≥n de pinyin en el lado derecho con HTML viewer optimizado"""
        # Frame principal del pinyin (lado derecho completo)
        self.frame_pinyin_principal = customtkinter.CTkFrame(self.main_container)
        self.frame_pinyin_principal.grid(row=1, column=1, sticky="nsew", padx=(2.5, 5), pady=5)
        self.frame_pinyin_principal.grid_columnconfigure(0, weight=1)
        self.frame_pinyin_principal.grid_rowconfigure(1, weight=1)
        
        # Header del pinyin con info
        header_pinyin = customtkinter.CTkFrame(self.frame_pinyin_principal)
        header_pinyin.grid(row=0, column=0, sticky="ew", padx=5, pady=(5, 10))
        header_pinyin.grid_columnconfigure(1, weight=1)
        
        label_pinyin = customtkinter.CTkLabel(
            header_pinyin,
            text="Pronunciaci√≥n Pinyin:",
            font=("Arial", 18, "bold")
        )
        label_pinyin.grid(row=0, column=0, pady=10, padx=10, sticky="w")
        
        # Info responsive con indicador de tecnolog√≠a
        tecnologia = "HTML‚ö°" if self.usar_html_viewer else "Tabla"
        self.info_pinyin = customtkinter.CTkLabel(
            header_pinyin,
            text=f"üí° {tecnologia} - Listo para mostrar pronunciaci√≥n",
            font=("Arial", 12),
            text_color="gray"
        )
        self.info_pinyin.grid(row=0, column=1, pady=10, padx=10, sticky="e")
        
        # Frame contenedor para el viewer
        self.frame_tabla_container = customtkinter.CTkFrame(self.frame_pinyin_principal)
        self.frame_tabla_container.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 5))
        self.frame_tabla_container.grid_columnconfigure(0, weight=1)
        self.frame_tabla_container.grid_rowconfigure(0, weight=1)
        
        # Crear viewer seg√∫n disponibilidad
        if self.usar_html_viewer:
            self.crear_html_viewer()
        else:
            self.crear_fallback_viewer()
        
        # Mostrar mensaje inicial
        self.mostrar_contenido_inicial()
    
    def crear_html_viewer(self):
        """Crea el viewer HTML optimizado sin conflictos de scroll"""
        try:
            # Frame normal como contenedor (sin scroll autom√°tico)
            self.html_container = customtkinter.CTkFrame(
                self.frame_tabla_container,
                corner_radius=8,
                fg_color=("white", "#1a1a1a")
            )
            self.html_container.grid(row=0, column=0, sticky="nsew", padx=3, pady=3)
            self.html_container.grid_columnconfigure(0, weight=1)
            self.html_container.grid_rowconfigure(0, weight=1)
            
            # HTML Frame optimizado con scroll propio
            if HTML_DISPONIBLE and HtmlFrameClass is not None:
                self.html_frame = HtmlFrameClass(
                    self.html_container,
                    messages_enabled=False,  # Desactivar mensajes para mejor rendimiento
                    vertical_scrollbar=True,  # Habilitar scroll interno del HTML
                    horizontal_scrollbar=False,  # Sin scroll horizontal
                    width=800,  # Ancho fijo para evitar problemas
                    height=400  # Alto fijo
                )
                self.html_frame.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
                
                # Variables de control
                self.tabla_pinyin = None  # Mantener compatibilidad
                self.modo_html_activo = True
                self.scrollable_frame = self.html_container  # Para compatibilidad
                
                print("HTML Viewer inicializado - Rendimiento ultra optimizado")
            else:
                raise ImportError("tkinterweb.HtmlFrame no disponible")
            
        except Exception as e:
            print(f"Error creando HTML viewer: {e}")
            self.usar_html_viewer = False
            self.crear_fallback_viewer()
    
    def crear_fallback_viewer(self):
        """Crea el viewer de fallback usando CTkTable"""
        print("Usando CTkTable como fallback")
        
        # Frame scrollable para la tabla
        self.scrollable_frame = customtkinter.CTkScrollableFrame(
            self.frame_tabla_container,
            corner_radius=8,
            scrollbar_button_color=("#2563eb", "#1d4ed8"),
            scrollbar_button_hover_color=("#1d4ed8", "#1e40af")
        )
        self.scrollable_frame.grid(row=0, column=0, sticky="nsew", padx=3, pady=3)
        self.scrollable_frame.grid_columnconfigure(0, weight=1)
        
        # Inicializar tabla vac√≠a
        self.tabla_pinyin = None
        self.modo_html_activo = False
        
        # Textbox para mostrar informaci√≥n
        self.texto_info = customtkinter.CTkTextbox(
            self.scrollable_frame,
            font=("Arial", 14),
            fg_color=("#f8f9fa", "#1a1a1a"),
            wrap="word",
            corner_radius=8,
            border_width=1,
            border_color=("#d1d5db", "#374151")
        )
        self.texto_info.grid(row=0, column=0, sticky="nsew", padx=8, pady=8)
    
    def mostrar_contenido_inicial(self):
        """Muestra el contenido inicial seg√∫n el modo activo"""
        if self.usar_html_viewer and hasattr(self, 'html_frame'):
            # Mostrar HTML inicial
            html_inicial = self.generador_html.generar_html_vacio()
            try:
                self.html_frame.load_html(html_inicial)
                print("HTML inicial cargado")
            except Exception as e:
                print(f"Error cargando HTML inicial: {e}")
        else:
            # Mostrar mensaje inicial en textbox
            self.mostrar_mensaje_inicial()
    
    def actualizar_contenido_pinyin_html(self, datos_tabla):
        """Actualiza el contenido Pinyin usando HTML optimizado"""
        if not self.usar_html_viewer or not hasattr(self, 'html_frame'):
            return False
        
        try:
            # Obtener contenido completo si est√° disponible
            contenido_completo = None
            if hasattr(self, 'contenido_completo_actual'):
                contenido_completo = self.contenido_completo_actual
            
            # Generar HTML optimizado con contenido completo
            html_contenido = self.generador_html.generar_html_optimizado(
                datos_tabla, 
                "Pronunciaci√≥n Pinyin - Ultra Optimizado",
                contenido_completo
            )
            
            # Cargar en viewer con manejo de errores
            self.html_frame.load_html(html_contenido)
            
            # Actualizar info
            total_filas = len(datos_tabla) if datos_tabla else 0
            self.info_pinyin.configure(text=f"üí° HTML‚ö° - {total_filas} filas cargadas")
            
            print(f"HTML Pinyin actualizado: {total_filas} filas")
            return True
            
        except Exception as e:
            print(f"Error actualizando HTML Pinyin: {e}")
            return False
    
    def abrir_html_en_navegador(self):
        """Abre la tabla HTML en el navegador por defecto como alternativa"""
        try:
            if not hasattr(self, 'datos_tabla_actual') or not self.datos_tabla_actual:
                self.mostrar_error("No hay tabla de Pinyin para mostrar")
                return
            
            # Obtener contenido completo si est√° disponible
            contenido_completo = None
            if hasattr(self, 'contenido_completo_actual'):
                contenido_completo = self.contenido_completo_actual
            
            # Generar HTML completo
            html_contenido = self.generador_html.generar_html_optimizado(
                self.datos_tabla_actual,
                "Traductor Chino - Tabla Pinyin Interactiva",
                contenido_completo
            )
            
            # Crear archivo temporal
            if not self.archivo_html_temp:
                temp_dir = tempfile.gettempdir()
                self.archivo_html_temp = os.path.join(temp_dir, "traductor_chino_pinyin.html")
            
            # Guardar y abrir
            with open(self.archivo_html_temp, 'w', encoding='utf-8') as f:
                f.write(html_contenido)
            
            webbrowser.open(f"file://{self.archivo_html_temp}")
            
            # Mostrar confirmaci√≥n
            self.info_pinyin.configure(text="üí° HTML‚ö° - Abierto en navegador")
            
        except Exception as e:
            self.mostrar_error(f"Error abriendo en navegador: {str(e)}")
    
    def limpiar_html_viewer(self):
        """Limpia el HTML viewer"""
        if self.usar_html_viewer and hasattr(self, 'html_frame'):
            try:
                html_vacio = self.generador_html.generar_html_vacio()
                self.html_frame.load_html(html_vacio)
                self.info_pinyin.configure(text="üí° HTML‚ö° - Listo para mostrar pronunciaci√≥n")
            except Exception as e:
                print(f"Error limpiando HTML viewer: {e}")
    
    def crear_barra_progreso(self):
        """Crea la barra de progreso para traducci√≥n"""
        # Frame para la barra de progreso
        self.frame_progreso = customtkinter.CTkFrame(self.main_container)
        self.frame_progreso.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=(5, 0))
        self.frame_progreso.grid_columnconfigure(0, weight=1)
        
        # Etiqueta de progreso
        self.label_progreso = customtkinter.CTkLabel(
            self.frame_progreso,
            text="Listo para traducir",
            font=("Arial", 12),
            text_color="gray"
        )
        self.label_progreso.grid(row=0, column=0, pady=2, sticky="w", padx=10)
        
        # Barra de progreso
        self.progress_bar = customtkinter.CTkProgressBar(
            self.frame_progreso,
            height=8,
            corner_radius=4
        )
        self.progress_bar.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 8))
        self.progress_bar.set(0)  # Inicializar en 0
        
        # Ocultar inicialmente
        self.frame_progreso.grid_remove()
    
    def mostrar_barra_progreso(self, texto="Procesando..."):
        """Muestra la barra de progreso con texto"""
        self.frame_progreso.grid()
        self.label_progreso.configure(text=texto)
        self.progress_bar.set(0)
        self.app.update()
    
    def actualizar_progreso(self, valor, texto=""):
        """Actualiza el progreso de la barra de manera no bloqueante"""
        try:
            # Control de frecuencia de actualizaci√≥n para evitar lag
            ahora = time.time()
            if ahora - self.ultimo_update < self.update_interval:
                return  # Skip si es demasiado frecuente
            
            self.ultimo_update = ahora
            
            if hasattr(self, 'progress_bar'):
                self.progress_bar.set(valor / 100.0)  # CTkProgressBar usa valores 0.0-1.0
                if texto:
                    self.label_progreso.configure(text=texto)
                
                # Update no bloqueante
                self.app.update_idletasks()  # M√°s eficiente que update()
        except Exception as e:
            print(f"Error actualizando progreso: {e}")
    
    def ocultar_barra_progreso(self):
        """Oculta la barra de progreso"""
        if hasattr(self, 'frame_progreso'):
            self.frame_progreso.grid_remove()
            self.app.update()
    
    def crear_seccion_pinyin(self):
        """Crea la secci√≥n de pinyin optimizada con CTkTable"""
        # Frame principal del pinyin
        self.frame_pinyin_principal = customtkinter.CTkFrame(self.main_container)
        self.frame_pinyin_principal.grid(row=3, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)
        self.frame_pinyin_principal.grid_columnconfigure(0, weight=1)
        self.frame_pinyin_principal.grid_rowconfigure(1, weight=1)
        
        # Header del pinyin con info
        header_pinyin = customtkinter.CTkFrame(self.frame_pinyin_principal)
        header_pinyin.grid(row=0, column=0, sticky="ew", padx=5, pady=(5, 0))
        header_pinyin.grid_columnconfigure(1, weight=1)
        
        label_pinyin = customtkinter.CTkLabel(
            header_pinyin,
            text="Pronunciaci√≥n Pinyin:",
            font=("Arial", 16, "bold")
        )
        label_pinyin.grid(row=0, column=0, pady=8, padx=10, sticky="w")
        
        # Info responsive
        self.info_pinyin = customtkinter.CTkLabel(
            header_pinyin,
            text="üí° Ingresa caracteres chinos para ver la pronunciaci√≥n",
            font=("Arial", 11),
            text_color="gray"
        )
        self.info_pinyin.grid(row=0, column=1, pady=8, padx=10, sticky="e")
        
        # Frame contenedor para la tabla con scroll
        self.frame_tabla_container = customtkinter.CTkFrame(self.frame_pinyin_principal)
        self.frame_tabla_container.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 5))
        self.frame_tabla_container.grid_columnconfigure(0, weight=1)
        self.frame_tabla_container.grid_rowconfigure(0, weight=1)
        
        # Frame scrollable para la tabla
        self.scrollable_frame = customtkinter.CTkScrollableFrame(
            self.frame_tabla_container,
            corner_radius=8,
            scrollbar_button_color=("#2563eb", "#1d4ed8"),
            scrollbar_button_hover_color=("#1d4ed8", "#1e40af")
        )
        self.scrollable_frame.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
        self.scrollable_frame.grid_columnconfigure(0, weight=1)
        
        # Inicializar tabla vac√≠a (se crear√° din√°micamente)
        self.tabla_pinyin = None
        
        # Textbox para mostrar informaci√≥n cuando no hay tabla
        self.texto_info = customtkinter.CTkTextbox(
            self.scrollable_frame,
            font=("Arial", 12),
            fg_color=("#f8f9fa", "#1a1a1a"),
            wrap="word",
            corner_radius=8,
            border_width=1,
            border_color=("#d1d5db", "#374151")
        )
        self.texto_info.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        # Mensaje inicial
        self.mostrar_mensaje_inicial()
    
    def mostrar_mensaje_inicial(self):
        """Muestra el mensaje inicial en el √°rea de informaci√≥n"""
        mensaje_inicial = (
            "üéå Traductor de Chino Optimizado - Ultra R√°pido ‚ö°\n\n"
            "üí° Instrucciones:\n"
            "‚Ä¢ Ingresa texto en chino en el campo izquierdo superior\n"
            "‚Ä¢ Haz clic en 'üá™üá∏ Espa√±ol' o 'üá∫üá∏ Ingl√©s' para traducir\n"
            "‚Ä¢ La traducci√≥n aparecer√° en el campo inferior izquierdo\n"
            "‚Ä¢ La pronunciaci√≥n Pinyin aparecer√° aqu√≠ con scroll\n"
            "‚Ä¢ Usa los botones de acci√≥n para traducir y copiar\n\n"
            "‚ö° Nuevas optimizaciones de velocidad:\n"
            "üî∏ Traducci√≥n as√≠ncrona en hilos separados\n"
            "üî∏ Barra de progreso visual en tiempo real\n"
            "üî∏ Cach√© inteligente para traducciones repetidas\n"
            "üî∏ Procesamiento por lotes de caracteres Pinyin\n"
            "üî∏ Bloqueo de botones durante procesamiento\n"
            "üî∏ L√≠mites optimizados para mejor rendimiento\n"
            "ÔøΩ Respeto mejorado de puntuaciones importantes (¬°!?, ÔºüÔºÅ„ÄÇ)\n"
            "ÔøΩüñ±Ô∏è Interfaz fluida ‚Ä¢ Progreso visible ‚Ä¢ ¬°M√°s r√°pido!\n\n"
            "üß™ Para probar el respeto de puntuaciones, escribe en la consola:\n"
            "traductor.probar_respeto_puntuaciones()"
        )
        self.texto_info.delete("1.0", "end")
        self.texto_info.insert("1.0", mensaje_inicial)
    
    # Funciones de copiado eliminadas seg√∫n solicitud del usuario
    
    def configurar_scroll_mejorado(self):
        """Configuraci√≥n de scroll ya no necesaria con CTkTable"""
        pass

    def on_window_resize_optimizado(self, event):
        """Manejo optimizado de redimensionamiento de ventana con debounce"""
        # Solo procesar eventos de la ventana principal, no de widgets hijos
        if event.widget != self.app:
            return
        
        # Cancelar timer anterior si existe (debounce)
        if self.resize_timer:
            self.app.after_cancel(self.resize_timer)
        
        # Programar ajuste con retraso para evitar m√∫ltiples llamadas
        self.resize_timer = self.app.after(150, self.ejecutar_ajuste_responsive)
    
    def ejecutar_ajuste_responsive(self):
        """Ejecuta el ajuste responsive de manera eficiente"""
        if self.ui_bloqueada:
            return
        
        try:
            self.ui_bloqueada = True
            self.ajustar_responsive_optimizado()
        except Exception as e:
            print(f"Error en ajuste responsive: {e}")
        finally:
            self.ui_bloqueada = False
            self.resize_timer = None
    
    def ajustar_responsive_optimizado(self):
        """Ajusta par√°metros responsive de manera m√°s eficiente"""
        try:
            # Obtener dimensiones actuales
            ancho_actual = self.app.winfo_width()
            alto_actual = self.app.winfo_height()
            
            # Solo actualizar si hay cambio significativo (> 50px)
            if (hasattr(self, 'ultimo_ancho') and 
                abs(ancho_actual - self.ultimo_ancho) < 50 and
                abs(alto_actual - self.ultimo_alto) < 50):
                return
            
            self.ultimo_ancho = ancho_actual
            self.ultimo_alto = alto_actual
            
            # C√°lculo optimizado de caracteres por l√≠nea
            if ancho_actual < 700:
                caracteres_linea = 4
                font_size = 16
            elif ancho_actual < 1100:
                caracteres_linea = 6
                font_size = 18
            else:
                caracteres_linea = 8
                font_size = 20
            
            # Actualizar solo si cambi√≥ significativamente
            if not hasattr(self, 'caracteres_por_linea') or self.caracteres_por_linea != caracteres_linea:
                self.caracteres_por_linea = caracteres_linea
                
                # Regenerar tabla solo si hay datos y cambi√≥ el layout
                if (hasattr(self, 'pinyin_actual') and self.pinyin_actual and 
                    hasattr(self, 'tabla_pinyin') and self.tabla_pinyin):
                    self.app.after_idle(self.regenerar_tabla_pinyin)
            
            # Actualizar fuentes de manera eficiente
            if not hasattr(self, 'ultimo_font_size') or self.ultimo_font_size != font_size:
                self.ultimo_font_size = font_size
                self.actualizar_fuentes_optimizado(font_size)
            
            # Actualizar info label responsive
            self.actualizar_info_responsive(ancho_actual)
                
        except Exception as e:
            print(f"Error en ajuste responsive optimizado: {e}")
    
    def actualizar_fuentes_optimizado(self, font_size):
        """Actualiza las fuentes de manera eficiente"""
        try:
            nueva_fuente = ("Arial", font_size)
            
            # Actualizar solo los campos principales
            if hasattr(self, 'texto_entrada'):
                self.texto_entrada.configure(font=nueva_fuente)
            if hasattr(self, 'texto_traduccion'):
                self.texto_traduccion.configure(font=nueva_fuente)
                
        except Exception as e:
            print(f"Error actualizando fuentes: {e}")
    
    def actualizar_info_responsive(self, ancho):
        """Actualiza el texto de informaci√≥n de manera responsive"""
        try:
            if hasattr(self, 'info_pinyin'):
                if ancho < 700:
                    texto = "üí° Pinyin"
                elif ancho < 1000:
                    texto = "üí° Pronunciaci√≥n"
                else:
                    texto = "üí° Ingresa caracteres chinos para ver la pronunciaci√≥n"
                
                if self.info_pinyin.cget("text") != texto:
                    self.info_pinyin.configure(text=texto)
        except:
            pass
    
    def regenerar_tabla_pinyin(self):
        """Regenera la tabla de pinyin con el layout actual"""
        if hasattr(self, 'pinyin_actual') and self.pinyin_actual:
            try:
                self.regenerar_tabla_pinyin()
            except Exception as e:
                print(f"Error regenerando tabla: {e}")
    
    def optimizacion_periodica(self):
        """Optimizaci√≥n peri√≥dica inteligente adaptada al hardware"""
        try:
            # Ejecutar optimizaciones en hilo separado para no bloquear UI
            def optimizar_en_hilo():
                try:
                    self.optimizar_cache_inteligente()
                    self.optimizar_memoria_sistema()
                    self.ajustar_parametros_dinamicos()
                    
                    # Programar siguiente optimizaci√≥n con intervalo adaptativo
                    intervalo = self.calcular_intervalo_optimizacion()
                    self.app.after(intervalo, self.optimizacion_periodica)
                    
                except Exception as e:
                    print(f"Error en optimizaci√≥n en hilo: {e}")
                    # Reprogramar de todos modos
                    self.app.after(30000, self.optimizacion_periodica)
            
            # Ejecutar en hilo separado si tenemos workers disponibles
            if hasattr(self, 'executor') and not self.executor._shutdown:
                self.executor.submit(optimizar_en_hilo)
            else:
                # Fallback a ejecuci√≥n directa
                optimizar_en_hilo()
                
        except Exception as e:
            print(f"Error en optimizaci√≥n peri√≥dica: {e}")
            # Reprogramar con intervalo por defecto
            self.app.after(30000, self.optimizacion_periodica)
    
    def optimizar_cache_inteligente(self):
        """Optimiza cach√©s de manera inteligente seg√∫n uso de memoria"""
        try:
            # Obtener uso actual de memoria
            memoria_actual = psutil.virtual_memory()
            porcentaje_uso = memoria_actual.percent
            
            # Ajustar l√≠mites de cach√© seg√∫n memoria disponible
            if porcentaje_uso > 85:  # Memoria muy ocupada
                self.limite_cache_mb = max(25, self.limite_cache_mb * 0.7)
                self.limpiar_cache_agresivo()
            elif porcentaje_uso < 50:  # Memoria disponible
                self.limite_cache_mb = min(300, self.limite_cache_mb * 1.1)
            
            # Limpiar cach√©s si exceden l√≠mites adaptativos
            self.gestionar_cache_traducciones()
            self.gestionar_cache_pinyin_periodico()
            
            print(f"Optimizaci√≥n cach√©: {porcentaje_uso}% memoria, l√≠mite: {self.limite_cache_mb}MB")
            
        except Exception as e:
            print(f"Error optimizando cach√©: {e}")
    
    def limpiar_cache_agresivo(self):
        """Limpieza agresiva de cach√© cuando la memoria es cr√≠tica"""
        try:
            # Reducir cach√© de traducciones a elementos esenciales
            if len(self.cache_traducciones) > 10:
                items_recientes = list(self.cache_traducciones.items())[-10:]
                self.cache_traducciones = dict(items_recientes)
            
            # Reducir cach√© de pinyin
            if len(self.cache_pinyin) > 5:
                items_recientes = list(self.cache_pinyin.items())[-5:]
                self.cache_pinyin = dict(items_recientes)
            
            # Forzar recolecci√≥n de basura
            gc.collect()
            print("Limpieza agresiva de cach√© ejecutada")
            
        except Exception as e:
            print(f"Error en limpieza agresiva: {e}")
    
    def gestionar_cache_traducciones(self):
        """Gestiona el cach√© de traducciones de manera inteligente"""
        try:
            limite_elementos = int(self.limite_cache_mb * 0.5)  # 50% del l√≠mite para traducciones
            
            if len(self.cache_traducciones) > limite_elementos:
                # Mantener elementos m√°s recientes
                items_mantener = int(limite_elementos * 0.8)
                items = list(self.cache_traducciones.items())[-items_mantener:]
                self.cache_traducciones = dict(items)
                print(f"Cach√© traducciones optimizado: {len(self.cache_traducciones)} elementos")
                
        except Exception as e:
            print(f"Error gestionando cach√© traducciones: {e}")
    
    def gestionar_cache_pinyin_periodico(self):
        """Gestiona el cach√© de pinyin de manera peri√≥dica"""
        try:
            limite_elementos = int(self.limite_cache_mb * 0.5)  # 50% del l√≠mite para pinyin
            
            if len(self.cache_pinyin) > limite_elementos:
                # Mantener elementos m√°s recientes
                items_mantener = int(limite_elementos * 0.8)
                items = list(self.cache_pinyin.items())[-items_mantener:]
                self.cache_pinyin = dict(items)
                print(f"Cach√© Pinyin optimizado: {len(self.cache_pinyin)} elementos")
                
        except Exception as e:
            print(f"Error gestionando cach√© pinyin: {e}")
    
    def optimizar_memoria_sistema(self):
        """Optimiza el uso de memoria del sistema"""
        try:
            # Verificar si necesitamos recolecci√≥n de basura
            memoria = psutil.virtual_memory()
            
            if memoria.percent > 80 or (hasattr(self, 'ultima_gc') and 
                                      time.time() - self.ultima_gc > self.frecuencia_gc):
                gc.collect()
                self.ultima_gc = time.time()
                print(f"Recolecci√≥n de basura ejecutada - Memoria: {memoria.percent}%")
            
        except Exception as e:
            print(f"Error optimizando memoria: {e}")
    
    def ajustar_parametros_dinamicos(self):
        """Ajusta par√°metros din√°micamente seg√∫n el estado del sistema"""
        try:
            # Ajustar interval de updates seg√∫n carga de CPU
            cpu_percent = psutil.cpu_percent(interval=0.1)
            
            if cpu_percent > 80:
                # CPU muy ocupada - reducir frecuencia de updates
                self.update_interval = min(0.05, self.update_interval * 1.2)
            elif cpu_percent < 30:
                # CPU disponible - aumentar frecuencia de updates
                self.update_interval = max(0.008, self.update_interval * 0.9)
            
            # Ajustar l√≠mite de segmento seg√∫n rendimiento
            if hasattr(self, 'tiempo_ultima_traduccion'):
                tiempo_transcurrido = time.time() - self.tiempo_ultima_traduccion
                if tiempo_transcurrido > 10:  # Traducci√≥n tard√≥ m√°s de 10s
                    self.limite_segmento = max(1000, int(self.limite_segmento * 0.8))
                elif tiempo_transcurrido < 3:  # Traducci√≥n r√°pida
                    self.limite_segmento = min(5000, int(self.limite_segmento * 1.1))
            
        except Exception as e:
            print(f"Error ajustando par√°metros din√°micos: {e}")
    
    def optimizar_rendimiento_ui(self):
        """Optimiza el rendimiento general de la UI"""
        try:
            # Limpiar cach√© si es muy grande (m√°s de 50 elementos)
            if len(self.cache_traducciones) > 50:
                # Mantener solo los 30 m√°s recientes
                items = list(self.cache_traducciones.items())[-30:]
                self.cache_traducciones = dict(items)
                print("Cach√© de traducciones optimizado")
            
            if len(self.cache_pinyin) > 50:
                # Mantener solo los 30 m√°s recientes
                items = list(self.cache_pinyin.items())[-30:]
                self.cache_pinyin = dict(items)
                print("Cach√© de pinyin optimizado")
            
            # Forzar recolecci√≥n de basura si es necesario
            import gc
            if len(self.cache_traducciones) + len(self.cache_pinyin) > 80:
                gc.collect()
                print("Recolecci√≥n de basura ejecutada")
            
        except Exception as e:
            print(f"Error optimizando rendimiento: {e}")
    
    def recargar_contenido_inteligente(self):
        """Recarga el contenido de manera inteligente usando variables de cach√©"""
        try:
            # Verificar si hay contenido en variables para recargar
            if (hasattr(self, 'traduccion_actual') and self.traduccion_actual and
                hasattr(self, 'texto_chino_actual') and self.texto_chino_actual):
                
                # Recargar desde variables sin re-procesar
                exito = self.cargar_traduccion_desde_variable()
                if exito:
                    print("Contenido recargado desde variables de cach√©")
                    return True
            
            # Si no hay variables, verificar cach√© de traducciones
            texto_actual = self.texto_entrada.get("1.0", "end-1c")
            if texto_actual.strip():
                cache_key = f"es_{texto_actual}"
                if cache_key in self.cache_traducciones:
                    traduccion = self.cache_traducciones[cache_key]
                    self.texto_traduccion.delete("1.0", "end")
                    self.texto_traduccion.insert("1.0", traduccion)
                    
                    # Recargar pinyin desde cach√©
                    pinyin_key = f"pinyin_{texto_actual}"
                    if pinyin_key in self.cache_pinyin:
                        datos_tabla = self.cache_pinyin[pinyin_key]
                        self.crear_tabla_pinyin_optimizada_desde_cache(datos_tabla)
                    
                    print("Contenido recargado desde cach√© de traducciones")
                    return True
            
            return False
            
        except Exception as e:
            print(f"Error recargando contenido inteligente: {e}")
            return False

    def traducir_chino_a_espanol(self):
        """Traduce texto del chino al espa√±ol espec√≠ficamente - funci√≥n principal"""
        self.traducir_a_espanol()
    
    def traducir_automatico(self):
        """Detecta autom√°ticamente el idioma y traduce con optimizaci√≥n"""
        texto = self.texto_entrada.get("1.0", "end-1c")
        if not texto.strip():
            self.mostrar_error("Por favor, ingresa un texto para traducir")
            return
        
        # Prevenir m√∫ltiples traducciones simult√°neas
        if self.traduccion_en_progreso:
            self.mostrar_error("Ya hay una traducci√≥n en progreso. Espera a que termine.")
            return
        
        try:
            # Detectar idioma r√°pidamente
            if self.es_texto_chino(texto):
                # Si es chino, traducir al espa√±ol (por defecto)
                self.traducir_a_espanol()
            else:
                # Si no es chino, usar traducci√≥n optimizada a chino
                self.deshabilitar_botones()
                
                def traducir_hilo():
                    try:
                        self.traduccion_en_progreso = True
                        self.app.after(0, lambda: self.mostrar_barra_progreso("Detectando idioma y traduciendo..."))
                        
                        self.app.after(0, lambda: self.actualizar_progreso(30, "Traduciendo a chino..."))
                        texto_traducido = self.traducir_texto_optimizado_a_chino(texto)
                        
                        # Mostrar traducci√≥n
                        def mostrar_resultado():
                            self.texto_traduccion.delete("1.0", "end")
                            self.texto_traduccion.insert("1.0", texto_traducido)
                            self.actualizar_progreso(80, "Generando Pinyin...")
                        
                        self.app.after(0, mostrar_resultado)
                        
                        # Generar pinyin
                        self.app.after(0, lambda: self.generar_pinyin_optimizado(texto_traducido))
                        
                        # Completar
                        self.app.after(0, lambda: self.actualizar_progreso(100, "¬°Traducci√≥n autom√°tica completada!"))
                        time.sleep(0.5)
                        self.app.after(0, self.ocultar_barra_progreso)
                        
                    except Exception as e:
                        self.app.after(0, lambda: self.mostrar_error(f"Error en la traducci√≥n autom√°tica: {str(e)}"))
                        self.app.after(0, self.ocultar_barra_progreso)
                    finally:
                        self.traduccion_en_progreso = False
                        self.app.after(0, self.habilitar_botones)
                
                self.executor.submit(traducir_hilo)
            
        except Exception as e:
            self.mostrar_error(f"Error en la traducci√≥n autom√°tica: {str(e)}")
    
    def traducir_texto_optimizado_a_chino(self, texto):
        """Versi√≥n optimizada de traducci√≥n al chino"""
        try:
            limite_segmento = 2000
            
            if len(texto) <= limite_segmento:
                traductor_chino = GoogleTranslator(source='auto', target='zh-CN')
                return traductor_chino.translate(texto)
            
            # Dividir por l√≠neas para mejor control
            lineas = texto.split('\n')
            lineas_traducidas = []
            total_lineas = len(lineas)
            
            for idx, linea in enumerate(lineas):
                progreso = 30 + (idx / total_lineas) * 40  # Entre 30% y 70%
                self.app.after(0, lambda p=progreso: self.actualizar_progreso(p, f"Traduciendo l√≠nea {idx+1}/{total_lineas}"))
                
                if not linea.strip():
                    lineas_traducidas.append('')
                    continue
                
                try:
                    traductor_chino = GoogleTranslator(source='auto', target='zh-CN')
                    linea_traducida = traductor_chino.translate(linea.strip())
                    lineas_traducidas.append(linea_traducida)
                except Exception as e:
                    print(f"Error traduciendo l√≠nea {idx} a chino: {e}")
                    lineas_traducidas.append(linea)
                
                time.sleep(0.1)  # Pausa breve
            
            return '\n'.join(lineas_traducidas)
            
        except Exception as e:
            raise Exception(f"Error en traducci√≥n optimizada a chino: {str(e)}")
    
    def traducir_a_chino(self):
        """Traduce texto del espa√±ol al chino con soporte para textos largos"""
        texto = self.texto_entrada.get("1.0", "end-1c")
        if not texto.strip():
            self.mostrar_error("Por favor, ingresa un texto para traducir")
            return
        
        try:
            # Traducir usando el sistema de chunks
            texto_chino = self.traducir_texto_largo_a_chino(texto)
            
            # Mostrar traducci√≥n preservando formato
            self.texto_traduccion.delete("1.0", "end")
            self.texto_traduccion.insert("1.0", texto_chino)
            
            # Generar pinyin
            self.generar_pinyin(texto_chino)
            
        except Exception as e:
            self.mostrar_error(f"Error en la traducci√≥n: {str(e)}")
    
    def traducir_texto_largo_a_chino(self, texto):
        """Traduce textos largos del espa√±ol/ingl√©s al chino preservando formato exacto"""
        try:
            # L√≠mite m√°s peque√±o para mejor precisi√≥n
            limite_segmento = 1500
            
            # Si el texto es corto, traducir directamente
            if len(texto) <= limite_segmento:
                traductor_chino = GoogleTranslator(source='auto', target='zh-CN')
                return traductor_chino.translate(texto)
            
            # Dividir por l√≠neas para preservar formato exacto
            lineas = texto.split('\n')
            lineas_traducidas = []
            
            for linea in lineas:
                if not linea.strip():  # L√≠nea vac√≠a
                    lineas_traducidas.append('')  # Preservar l√≠neas vac√≠as
                    continue
                
                # Si la l√≠nea es muy larga, dividirla por oraciones
                if len(linea) > limite_segmento:
                    # Dividir por puntuaciones para respetar el contexto
                    segmentos = self.dividir_linea_en_segmentos_occidentales(linea, limite_segmento)
                    segmentos_traducidos = []
                    
                    for segmento in segmentos:
                        if segmento.strip():
                            try:
                                traductor_chino = GoogleTranslator(source='auto', target='zh-CN')
                                segmento_traducido = traductor_chino.translate(segmento.strip())
                                segmentos_traducidos.append(segmento_traducido)
                            except Exception as e:
                                print(f"Error traduciendo segmento a chino: {e}")
                                segmentos_traducidos.append(segmento)  # Mantener original si falla
                    
                    # Unir segmentos de la l√≠nea
                    linea_completa = ''.join(segmentos_traducidos)  # Sin espacios para chino
                    lineas_traducidas.append(linea_completa)
                else:
                    # L√≠nea corta, traducir directamente
                    try:
                        traductor_chino = GoogleTranslator(source='auto', target='zh-CN')
                        linea_traducida = traductor_chino.translate(linea)
                        lineas_traducidas.append(linea_traducida)
                    except Exception as e:
                        print(f"Error traduciendo l√≠nea a chino: {e}")
                        lineas_traducidas.append(linea)  # Mantener original si falla
            
            # Unir todas las l√≠neas preservando saltos de l√≠nea exactos
            return '\n'.join(lineas_traducidas)
            
        except Exception as e:
            raise Exception(f"Error en traducci√≥n a chino por segmentos: {str(e)}")
    
    def dividir_linea_en_segmentos_occidentales(self, linea, limite):
        """Divide una l√≠nea en idiomas occidentales en segmentos respetando puntuaciones importantes"""
        if len(linea) <= limite:
            return [linea]
        
        segmentos = []
        segmento_actual = ""
        
        # Puntuaciones que indican fin de oraci√≥n o pausa en idiomas occidentales (mejoradas)
        puntuaciones_corte = ['.', '!', '?', ';', '„ÄÇ', 'ÔºÅ', 'Ôºü', 'Ôºõ']  # Incluyendo chinas
        puntuaciones_pausa = [',', ':', ')', ']', '}', 'Ôºå', 'Ôºö', 'Ôºâ', '„Äë', '„Äã']  # Incluyendo chinas
        puntuaciones_enfasis = ['!', '?', 'ÔºÅ', 'Ôºü']  # Puntuaciones que requieren √©nfasis especial
        
        i = 0
        while i < len(linea):
            char = linea[i]
            segmento_actual += char
            
            # Si alcanzamos el l√≠mite, buscar un punto de corte apropiado
            if len(segmento_actual) >= limite:
                # Buscar punto de corte hacia atr√°s
                punto_corte = -1
                
                # Primero buscar puntuaciones de corte (especialmente exclamaci√≥n y pregunta)
                for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 200), -1):
                    if segmento_actual[j] in puntuaciones_corte:
                        punto_corte = j + 1
                        # Si es una puntuaci√≥n de √©nfasis, asegurarse de que se incluya completa
                        if segmento_actual[j] in puntuaciones_enfasis:
                            # Verificar si hay espacios adicionales despu√©s para incluirlos
                            k = j + 1
                            while k < len(segmento_actual) and segmento_actual[k] in ' \n\t':
                                k += 1
                            punto_corte = k
                        break
                
                # Si no encontramos puntuaci√≥n de corte, buscar puntuaci√≥n de pausa
                if punto_corte == -1:
                    for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 100), -1):
                        if segmento_actual[j] in puntuaciones_pausa:
                            punto_corte = j + 1
                            break
                
                # Si no encontramos nada, cortar en espacio
                if punto_corte == -1:
                    for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 50), -1):
                        if segmento_actual[j] == ' ':
                            punto_corte = j + 1
                            break
                
                # Si a√∫n no encontramos, cortar forzosamente
                if punto_corte == -1:
                    punto_corte = limite
                
                # Agregar segmento y continuar
                segmentos.append(segmento_actual[:punto_corte])
                segmento_actual = segmento_actual[punto_corte:]
                # No incrementar i porque ya avanzamos en segmento_actual
                continue
            
            i += 1
        
        # Agregar el √∫ltimo segmento si queda algo
        if segmento_actual.strip():
            segmentos.append(segmento_actual)
        
        return segmentos
    
    def traducir_a_espanol(self):
        """Traduce texto del chino al espa√±ol con barra de progreso y optimizaci√≥n"""
        texto = self.texto_entrada.get("1.0", "end-1c")
        if not texto.strip():
            self.mostrar_error("Por favor, ingresa texto en chino para traducir")
            return
        
        # Prevenir m√∫ltiples traducciones simult√°neas
        if self.traduccion_en_progreso:
            self.mostrar_error("Ya hay una traducci√≥n en progreso. Espera a que termine.")
            return
        
        # Deshabilitar botones durante traducci√≥n
        self.deshabilitar_botones()
        
        # Ejecutar traducci√≥n en hilo separado
        def traducir_hilo():
            try:
                self.traduccion_en_progreso = True
                self.app.after(0, lambda: self.mostrar_barra_progreso("Iniciando traducci√≥n..."))
                
                # Verificar cach√© primero
                cache_key = f"es_{texto}"
                if cache_key in self.cache_traducciones:
                    self.app.after(0, lambda: self.actualizar_progreso(50, "Recuperando del cach√©..."))
                    texto_espanol = self.cache_traducciones[cache_key]
                    self.app.after(0, lambda: self.actualizar_progreso(80, "Cach√© recuperado"))
                else:
                    # Traducir texto optimizado
                    self.app.after(0, lambda: self.actualizar_progreso(20, "Analizando texto..."))
                    texto_espanol = self.traducir_texto_optimizado(texto, 'es')
                    # Guardar en cach√©
                    self.cache_traducciones[cache_key] = texto_espanol
                    self.app.after(0, lambda: self.actualizar_progreso(80, "Traducci√≥n completada"))
                
                # Mostrar traducci√≥n
                def mostrar_resultado():
                    self.texto_traduccion.delete("1.0", "end")
                    self.texto_traduccion.insert("1.0", texto_espanol)
                    # Guardar en variables para uso posterior
                    self.traduccion_actual = texto_espanol
                    self.texto_chino_actual = texto
                    self.actualizar_progreso(90, "Mostrando traducci√≥n...")
                
                self.app.after(0, mostrar_resultado)
                
                # Generar pinyin si es necesario
                if self.es_texto_chino(texto):
                    self.app.after(0, lambda: self.actualizar_progreso(95, "Generando tabla Pinyin..."))
                    self.app.after(0, lambda: self.generar_pinyin_optimizado(texto))
                
                # Completar
                self.app.after(0, lambda: self.actualizar_progreso(100, "¬°Traducci√≥n completada!"))
                time.sleep(0.5)  # Mostrar brevemente el 100%
                self.app.after(0, self.ocultar_barra_progreso)
                
            except Exception as e:
                self.app.after(0, lambda: self.mostrar_error(f"Error en la traducci√≥n: {str(e)}"))
                self.app.after(0, self.ocultar_barra_progreso)
            finally:
                self.traduccion_en_progreso = False
                self.app.after(0, self.habilitar_botones)
        
        # Ejecutar en hilo separado
        self.executor.submit(traducir_hilo)
    
    def traducir_texto_optimizado(self, texto, idioma_destino):
        """Versi√≥n ultra optimizada de traducci√≥n con gesti√≥n adaptativa de recursos"""
        try:
            # Usar l√≠mite adaptativo calculado seg√∫n hardware
            limite_segmento = self.limite_segmento
            
            # Para textos cortos, traducir directamente
            if len(texto) <= limite_segmento:
                traductor = GoogleTranslator(
                    source='zh-CN', 
                    target='es' if idioma_destino == 'es' else 'en'
                )
                return traductor.translate(texto)
            
            # Procesamiento por chunks adaptativos
            return self.procesar_texto_por_chunks_adaptativos(texto, idioma_destino)
            
        except Exception as e:
            raise Exception(f"Error en traducci√≥n ultra optimizada: {str(e)}")
    
    def procesar_texto_por_chunks_adaptativos(self, texto, idioma_destino):
        """Procesa texto en chunks adaptativos seg√∫n el hardware"""
        try:
            lineas = texto.split('\n')
            lineas_traducidas = []
            total_lineas = len(lineas)
            
            # Procesamiento en lotes seg√∫n capacidad de hardware
            batch_size = self.calcular_batch_size(total_lineas)
            
            for i in range(0, total_lineas, batch_size):
                batch_lineas = lineas[i:i + batch_size]
                
                # Procesar lote
                batch_traducido = self.procesar_batch_lineas(batch_lineas, idioma_destino)
                lineas_traducidas.extend(batch_traducido)
                
                # Update progreso m√°s eficiente
                progreso = 20 + ((i + batch_size) / total_lineas) * 50
                self.update_progreso_eficiente(
                    progreso, 
                    f"Procesando lote {(i//batch_size)+1}/{(total_lineas//batch_size)+1}"
                )
                
                # Pausa adaptativa
                tiempo_pausa = self.calcular_pausa_adaptativa()
                if tiempo_pausa > 0:
                    time.sleep(tiempo_pausa)
            
            return '\n'.join(lineas_traducidas)
            
        except Exception as e:
            raise Exception(f"Error en procesamiento por chunks: {str(e)}")
    
    def calcular_batch_size(self, total_lineas):
        """Calcula el tama√±o de lote √≥ptimo seg√∫n hardware"""
        try:
            hw = self.hardware_info
            
            # Base seg√∫n n√∫mero de workers
            base_batch = max(1, self.max_workers // 2)
            
            # Ajustar seg√∫n memoria disponible
            if hw['memory_available_gb'] >= 8:
                batch_multiplier = 3
            elif hw['memory_available_gb'] >= 4:
                batch_multiplier = 2
            else:
                batch_multiplier = 1
            
            batch_size = base_batch * batch_multiplier
            
            # Limitar seg√∫n total de l√≠neas
            return min(batch_size, max(1, total_lineas // 4))
            
        except:
            return 2  # Valor seguro por defecto
    
    def procesar_batch_lineas(self, lineas, idioma_destino):
        """Procesa un lote de l√≠neas de manera optimizada"""
        resultado = []
        
        for linea in lineas:
            if not linea.strip():
                resultado.append('')
                continue
            
            try:
                traductor = GoogleTranslator(
                    source='zh-CN', 
                    target='es' if idioma_destino == 'es' else 'en'
                )
                linea_traducida = traductor.translate(linea.strip())
                resultado.append(linea_traducida)
            except Exception as e:
                print(f"Error traduciendo l√≠nea: {e}")
                resultado.append(linea)  # Mantener original si falla
        
        return resultado
    
    def calcular_pausa_adaptativa(self):
        """Calcula pausa adaptativa para evitar sobrecarga de API"""
        try:
            hw = self.hardware_info
            
            if hw['is_high_end']:
                return 0.05  # Pausa m√≠nima para hardware potente
            elif hw['is_low_end']:
                return 0.2   # Pausa mayor para hardware limitado
            else:
                return 0.1   # Pausa est√°ndar
                
        except:
            return 0.1
    
    def update_progreso_eficiente(self, valor, texto=""):
        """Update de progreso ultra eficiente para evitar bloqueos"""
        try:
            # Control de frecuencia adaptativo
            ahora = time.time()
            if ahora - self.ultimo_update < self.update_interval:
                return
            
            self.ultimo_update = ahora
            
            # Usar queue para update no bloqueante si est√° disponible
            if hasattr(self, 'ui_update_queue') and not self.ui_update_queue.full():
                update_func = lambda: self.actualizar_progreso_directo(valor, texto)
                self.ui_update_queue.put(update_func)
            else:
                # Fallback a update directo con throttling
                self.actualizar_progreso_directo(valor, texto)
                
        except Exception as e:
            print(f"Error en update progreso eficiente: {e}")
    
    def actualizar_progreso_directo(self, valor, texto=""):
        """Update directo de progreso con m√≠nimo bloqueo"""
        try:
            if hasattr(self, 'progress_bar'):
                self.progress_bar.set(valor / 100.0)
                if texto and hasattr(self, 'label_progreso'):
                    self.label_progreso.configure(text=texto)
                
                # Update ultra eficiente
                self.app.update_idletasks()
                
        except Exception as e:
            print(f"Error en update directo: {e}")
    
    def generar_pinyin_optimizado(self, texto_chino):
        """Versi√≥n ultra optimizada de generaci√≥n de pinyin con recursos adaptativos"""
        try:
            if not texto_chino.strip():
                return
            
            # Guardar en variable para uso posterior
            self.pinyin_actual = texto_chino
            
            # Verificar cach√© primero con sistema inteligente
            cache_key = f"pinyin_{hash(texto_chino)}"  # Hash para claves m√°s eficientes
            if cache_key in self.cache_pinyin:
                datos_tabla = self.cache_pinyin[cache_key]
                self.crear_tabla_pinyin_ultra_optimizada(datos_tabla)
                return
            
            # Verificar si contiene caracteres chinos de manera eficiente
            if not self.contiene_caracteres_chinos_rapido(texto_chino):
                self.mostrar_error_pinyin("No se encontraron caracteres chinos v√°lidos")
                return
            
            # Generar datos con procesamiento por lotes adaptativos
            datos_tabla = self.crear_datos_pinyin_ultra_rapido(texto_chino)
            
            # Guardar en cach√© con l√≠mite inteligente
            self.gestionar_cache_inteligente(cache_key, datos_tabla)
            
            # Crear tabla de manera no bloqueante
            self.crear_tabla_pinyin_ultra_optimizada(datos_tabla)
            
            # Actualizar contenido completo para copiado
            self.actualizar_contenido_completo(texto_chino, datos_tabla)
            
        except Exception as e:
            print(f"Error en generar_pinyin_ultra_optimizado: {e}")
            self.mostrar_error_pinyin(f"Error generando Pinyin: {str(e)}")
    
    def actualizar_contenido_completo(self, texto_chino, datos_tabla):
        """Actualiza la variable de contenido completo con toda la informaci√≥n"""
        try:
            # Obtener texto original del campo de entrada
            texto_original = self.texto_entrada.get("1.0", "end-1c").strip()
            
            # Crear formato markdown para la tabla
            markdown_completo = self.crear_markdown_completo(texto_original, datos_tabla)
            
            # Actualizar la variable de contenido completo
            self.contenido_completo_actual = {
                'texto_original': texto_original,
                'traduccion': self.traduccion_actual,
                'datos_pinyin': datos_tabla,
                'formato_markdown': markdown_completo
            }
            
        except Exception as e:
            print(f"Error actualizando contenido completo: {e}")
    
    def crear_markdown_completo(self, texto_original, datos_tabla):
        """Crea formato markdown completo con toda la informaci√≥n"""
        try:
            markdown = "# üìã Traducci√≥n Completa con Pinyin\n\n"
            
            # Agregar traducci√≥n en ingl√©s (texto principal)
            if self.traduccion_actual:
                markdown += f"## üåê Traducci√≥n al Ingl√©s\n{self.traduccion_actual}\n\n"
            
            # Agregar texto original en chino
            if texto_original:
                markdown += f"## üÄÑ Texto Original (Chino)\n{texto_original}\n\n"
            
            # Agregar tabla de pinyin con formato mejorado
            if datos_tabla:
                markdown += "## üìö Tabla de Pronunciaci√≥n Pinyin\n\n"
                
                # Procesar datos de tabla para coincidir con el HTML viewer
                filas_procesadas = []
                fila_pinyin_actual = []
                fila_caracteres_actual = []
                
                for i, fila in enumerate(datos_tabla):
                    if len(fila) == 1 and fila[0] == "‚≠ê":
                        # Es un separador - procesar las filas acumuladas
                        if fila_pinyin_actual and fila_caracteres_actual:
                            filas_procesadas.append({
                                'pinyin': fila_pinyin_actual,
                                'caracteres': fila_caracteres_actual
                            })
                            fila_pinyin_actual = []
                            fila_caracteres_actual = []
                    else:
                        # Determinar si es fila de pinyin o caracteres
                        es_fila_pinyin = any(c.isalpha() for celda in fila for c in str(celda))
                        
                        if es_fila_pinyin:
                            fila_pinyin_actual = [str(celda) for celda in fila if str(celda).strip()]
                        else:
                            fila_caracteres_actual = [str(celda) for celda in fila if str(celda).strip()]
                
                # Procesar √∫ltima fila si no termin√≥ con separador
                if fila_pinyin_actual and fila_caracteres_actual:
                    filas_procesadas.append({
                        'pinyin': fila_pinyin_actual,
                        'caracteres': fila_caracteres_actual
                    })
                
                # Crear tabla markdown
                if filas_procesadas:
                    markdown += "| Pinyin | Caracteres Chinos |\n"
                    markdown += "|--------|------------------|\n"
                    
                    for grupo in filas_procesadas:
                        pinyin_texto = " ".join(grupo['pinyin'])
                        caracteres_texto = " ".join(grupo['caracteres'])
                        markdown += f"| {pinyin_texto} | {caracteres_texto} |\n"
                    
                    markdown += f"\n**Total:** {len(filas_procesadas)} grupos de caracteres\n"
            
            markdown += "\n---\n*Generado por Traductor de Chino Ultra Optimizado* ‚ö°"
            return markdown
            
        except Exception as e:
            print(f"Error creando markdown completo: {e}")
            return ""
    
    def contiene_caracteres_chinos_rapido(self, texto):
        """Verificaci√≥n r√°pida de caracteres chinos"""
        try:
            # Verificaci√≥n optimizada usando any() con generator
            return any('\u4e00' <= c <= '\u9fff' for c in texto[:100])  # Solo primeros 100 chars
        except:
            return False
    
    def crear_datos_pinyin_ultra_rapido(self, texto_completo):
        """Versi√≥n ultra r√°pida de creaci√≥n de datos pinyin con batching"""
        try:
            # Calcular caracteres por l√≠nea adaptativos
            if not hasattr(self, 'caracteres_por_linea'):
                self.caracteres_por_linea = self.calcular_caracteres_por_linea_adaptativos(texto_completo)
            
            datos = []
            lineas = texto_completo.split('\n')
            
            # Procesamiento por lotes para mejor rendimiento
            batch_size = self.caracteres_por_lote
            
            for idx_linea, linea in enumerate(lineas):
                if not linea.strip():
                    # Separador compacto en lugar de l√≠nea grande
                    datos.append(['‚≠ê'])
                    continue
                
                # Procesar l√≠nea en chunks
                datos_linea = self.procesar_linea_pinyin_por_chunks(linea, batch_size)
                datos.extend(datos_linea)
                
                # Update progreso eficiente cada cierto n√∫mero de l√≠neas
                if idx_linea % max(1, len(lineas) // 10) == 0:
                    progreso = 80 + (idx_linea / len(lineas)) * 15
                    self.update_progreso_eficiente(progreso, f"Generando Pinyin: {idx_linea+1}/{len(lineas)}")
                
                # Separador compacto entre l√≠neas si no es la √∫ltima
                if idx_linea < len(lineas) - 1 and linea.strip():
                    datos.append(['‚≠ê'])
            
            return datos
            
        except Exception as e:
            print(f"Error creando datos pinyin ultra r√°pido: {e}")
            return []
    
    def calcular_caracteres_por_linea_adaptativos(self, texto):
        """Calcula caracteres por l√≠nea de manera adaptativa"""
        try:
            total_chars_chinos = sum(1 for c in texto if '\u4e00' <= c <= '\u9fff')
            hw = self.hardware_info
            
            # Base seg√∫n hardware
            if hw['is_high_end']:
                base_chars = 12
            elif hw['is_low_end']:
                base_chars = 6
            else:
                base_chars = 8
            
            # Ajustar seg√∫n cantidad de texto
            if total_chars_chinos > 500:
                return min(base_chars + 4, 16)
            elif total_chars_chinos > 200:
                return base_chars + 2
            else:
                return base_chars
                
        except:
            return 8
    
    def procesar_linea_pinyin_por_chunks(self, linea, batch_size):
        """Procesa una l√≠nea de pinyin en chunks para mejor rendimiento"""
        try:
            caracteres_linea = list(linea)
            datos_linea = []
            
            for i in range(0, len(caracteres_linea), self.caracteres_por_linea):
                grupo = caracteres_linea[i:i + self.caracteres_por_linea]
                
                # Procesar grupo de caracteres
                fila_datos = self.procesar_grupo_caracteres_optimizado(grupo)
                if fila_datos:
                    datos_linea.extend(fila_datos)
            
            return datos_linea
            
        except Exception as e:
            print(f"Error procesando l√≠nea por chunks: {e}")
            return []
    
    def procesar_grupo_caracteres_optimizado(self, grupo):
        """Procesa un grupo de caracteres de manera ultra optimizada"""
        try:
            fila_pinyin = []
            fila_caracteres = []
            
            # Extraer solo caracteres chinos para procesamiento en lote
            caracteres_chinos = [(i, c) for i, c in enumerate(grupo) if '\u4e00' <= c <= '\u9fff']
            
            # Procesar pinyin en lote si hay caracteres chinos
            pinyin_dict = {}
            if caracteres_chinos:
                try:
                    chars_solo = [c for _, c in caracteres_chinos]
                    pinyin_lote = lazy_pinyin(chars_solo, style=Style.TONE)
                    pinyin_dict = {chars_solo[i]: pinyin_lote[i] for i in range(len(chars_solo))}
                except Exception as e:
                    print(f"Error en pinyin lote: {e}")
            
            # Construir filas con manejo mejorado de puntuaciones
            for char in grupo:
                if '\u4e00' <= char <= '\u9fff':
                    # Car√°cter chino
                    pinyin_char = pinyin_dict.get(char, char)
                    fila_pinyin.append(pinyin_char)
                    fila_caracteres.append(char)
                elif char in '.,!?;:„ÄÇÔºåÔºÅÔºüÔºõÔºö()ÔºàÔºâ[]„Äê„Äë""''':
                    # Puntuaci√≥n importante - preservar con emoji
                    emoji_map = {
                        '!': '‚ùó', '?': '‚ùì', 'ÔºÅ': '‚ùó', 'Ôºü': '‚ùì',
                        '.': '‚≠ê', '„ÄÇ': '‚≠ê', ',': 'üí´', 'Ôºå': 'üí´',
                        ':': 'üî∏', 'Ôºö': 'üî∏', ';': 'üîπ', 'Ôºõ': 'üîπ'
                    }
                    emoji = emoji_map.get(char, 'üìå')
                    fila_pinyin.append(f"{emoji}{char}")
                    fila_caracteres.append(char)
                elif char.strip():
                    # Otros caracteres no vac√≠os
                    fila_pinyin.append('¬∑')
                    fila_caracteres.append(char)
                else:
                    # Espacios
                    fila_pinyin.append(' ')
                    fila_caracteres.append(' ')
            
            # Devolver filas si hay contenido
            if fila_pinyin and any(p.strip() for p in fila_pinyin):
                return [fila_pinyin, fila_caracteres]
            
            return []
            
        except Exception as e:
            print(f"Error procesando grupo: {e}")
            return []
    
    def gestionar_cache_inteligente(self, cache_key, datos):
        """Gestiona el cach√© de manera inteligente seg√∫n memoria disponible"""
        try:
            # Calcular tama√±o aproximado del cach√©
            cache_size_mb = len(self.cache_pinyin) * 0.1  # Estimaci√≥n aproximada
            
            # Limpiar cach√© si excede el l√≠mite
            if cache_size_mb > self.limite_cache_mb:
                # Mantener solo los elementos m√°s recientes
                elementos_mantener = int(self.limite_cache_mb * 10)  # Conversi√≥n inversa
                items = list(self.cache_pinyin.items())[-elementos_mantener:]
                self.cache_pinyin = dict(items)
                print(f"Cach√© Pinyin optimizado: {len(self.cache_pinyin)} elementos")
            
            # Agregar nuevo elemento
            self.cache_pinyin[cache_key] = datos
            
        except Exception as e:
            print(f"Error gestionando cach√©: {e}")
    
    def crear_tabla_pinyin_ultra_optimizada(self, datos_tabla):
        """Crea tabla de pinyin con optimizaci√≥n ultra usando HTML o CTkTable"""
        try:
            if not datos_tabla:
                return
            
            # Guardar datos para usar en otras funciones
            self.datos_tabla_actual = datos_tabla
            
            # Verificar si necesitamos recrear
            if (hasattr(self, 'ultima_tabla_hash')):
                nuevo_hash = hash(str(datos_tabla))
                if hasattr(self, 'ultima_tabla_hash') and self.ultima_tabla_hash == nuevo_hash:
                    return  # Tabla ya actualizada
                self.ultima_tabla_hash = nuevo_hash
            else:
                self.ultima_tabla_hash = hash(str(datos_tabla))
            
            # Intentar usar HTML viewer primero
            if self.usar_html_viewer:
                exito = self.actualizar_contenido_pinyin_html(datos_tabla)
                if exito:
                    print("Tabla Pinyin creada con HTML ultra optimizado")
                    return
                else:
                    print("Fallback a CTkTable por error en HTML")
                    self.usar_html_viewer = False
            
            # Fallback a CTkTable
            self.programar_update_no_bloqueante(lambda: self.crear_tabla_ctk_fallback(datos_tabla))
            
        except Exception as e:
            print(f"Error creando tabla ultra optimizada: {e}")
            self.mostrar_error_pinyin(f"Error mostrando tabla Pinyin: {str(e)}")
    
    def crear_tabla_ctk_fallback(self, datos_tabla):
        """Crea tabla usando CTkTable como fallback"""
        try:
            # Limpiar tabla anterior si existe
            if hasattr(self, 'tabla_pinyin') and self.tabla_pinyin:
                self.tabla_pinyin.destroy()
            
            # Ocultar texto de info si existe
            if hasattr(self, 'texto_info'):
                self.texto_info.grid_remove()
            
            # Configurar tabla
            filas = len(datos_tabla)
            columnas = max(len(fila) if fila else 1 for fila in datos_tabla) if datos_tabla else 1
            
            # Crear tabla CTk optimizada
            self.tabla_pinyin = CTkTable(
                master=self.scrollable_frame,
                row=filas,
                column=columnas,
                values=datos_tabla,
                corner_radius=8,
                header_color=("#2563eb", "#1d4ed8"),
                hover_color=("#f1f5f9", "#2d3748"),
                text_color=("#1f2937", "#f9fafb"),
                font=("Arial", 14 if self.hardware_info['is_high_end'] else 12)
            )
            
            self.tabla_pinyin.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
            
            # Actualizar info
            self.info_pinyin.configure(text=f"üí° Tabla - {filas} filas cargadas")
            print(f"Tabla CTk creada: {filas}x{columnas}")
            
        except Exception as e:
            print(f"Error creando tabla CTk: {e}")
            self.mostrar_error_pinyin(f"Error mostrando tabla: {str(e)}")
    
    def crear_tabla_pinyin_optimizada_desde_cache(self, datos_tabla):
        """Crea tabla de pinyin optimizada usando datos de cach√©"""
        try:
            if not datos_tabla:
                return
            
            # Verificar si ya existe la tabla y evitar recrearla innecesariamente
            if (hasattr(self, 'tabla_pinyin') and self.tabla_pinyin and 
                hasattr(self, 'ultima_tabla_datos') and 
                self.ultima_tabla_datos == datos_tabla):
                return  # La tabla ya est√° actualizada
            
            # Guardar referencia para evitar recreaciones
            self.ultima_tabla_datos = datos_tabla
            
            # Crear la tabla de manera eficiente
            self.crear_tabla_pinyin(datos_tabla)
            
        except Exception as e:
            print(f"Error creando tabla desde cach√©: {e}")
    
    def cargar_traduccion_desde_variable(self):
        """Carga la traducci√≥n desde las variables en cach√© para evitar re-procesamiento"""
        try:
            if hasattr(self, 'traduccion_actual') and self.traduccion_actual:
                # Cargar traducci√≥n en UI
                self.texto_traduccion.delete("1.0", "end")
                self.texto_traduccion.insert("1.0", self.traduccion_actual)
                
                # Cargar pinyin si existe
                if hasattr(self, 'texto_chino_actual') and self.texto_chino_actual:
                    self.generar_pinyin_optimizado(self.texto_chino_actual)
                
                return True
            return False
        except Exception as e:
            print(f"Error cargando desde variables: {e}")
            return False
    
    def crear_datos_pinyin_rapido(self, texto_completo):
        """Versi√≥n m√°s r√°pida de creaci√≥n de datos pinyin"""
        if not hasattr(self, 'caracteres_por_linea'):
            self.caracteres_por_linea = 8  # Aumentado para mejor rendimiento
        
        # Ajuste r√°pido de caracteres por l√≠nea
        total_chars_chinos = sum(1 for c in texto_completo if '\u4e00' <= c <= '\u9fff')
        if total_chars_chinos > 200:
            self.caracteres_por_linea = 12
        elif total_chars_chinos > 100:
            self.caracteres_por_linea = 10
        else:
            self.caracteres_por_linea = 8
        
        datos = []
        lineas = texto_completo.split('\n')
        
        # Procesamiento optimizado por lotes
        for idx_linea, linea in enumerate(lineas):
            if not linea.strip():
                datos.append(['‚îà' * min(3, self.caracteres_por_linea)])
                continue
            
            # Procesar caracteres en grupos m√°s grandes
            caracteres_linea = list(linea)
            
            for i in range(0, len(caracteres_linea), self.caracteres_por_linea):
                grupo = caracteres_linea[i:i + self.caracteres_por_linea]
                
                fila_pinyin = []
                fila_caracteres = []
                
                # Procesamiento por lotes de pinyin para mejor rendimiento
                caracteres_chinos = [c for c in grupo if '\u4e00' <= c <= '\u9fff']
                if caracteres_chinos:
                    try:
                        # Procesar m√∫ltiples caracteres a la vez
                        pinyin_resultados = pinyin(caracteres_chinos, style=Style.TONE, heteronym=False)
                        pinyin_dict = {char: resultado[0] if resultado else "?" 
                                     for char, resultado in zip(caracteres_chinos, pinyin_resultados)}
                    except:
                        pinyin_dict = {char: "?" for char in caracteres_chinos}
                else:
                    pinyin_dict = {}
                
                # Construir filas con mejor manejo de puntuaciones importantes
                for char in grupo:
                    if '\u4e00' <= char <= '\u9fff':
                        fila_pinyin.append(pinyin_dict.get(char, "?"))
                        fila_caracteres.append(f' {char} ')
                    # Puntuaciones chinas importantes (respetadas con mayor √©nfasis)
                    elif char in 'ÔºÅÔºü„ÄÇÔºåÔºõÔºö':
                        if char == 'ÔºÅ':
                            fila_pinyin.append('‚ùóÔ∏èEXCL')
                            fila_caracteres.append(f'„Äê{char}„Äë')
                        elif char == 'Ôºü':
                            fila_pinyin.append('‚ùìPREG')
                            fila_caracteres.append(f'„Äê{char}„Äë')
                        elif char == '„ÄÇ':
                            fila_pinyin.append('‚≠ïPUNTO')
                            fila_caracteres.append(f'„Ää{char}„Äã')
                        else:
                            fila_pinyin.append(f'‚óè{char}‚óè')
                            fila_caracteres.append(char)
                    # Puntuaciones occidentales importantes
                    elif char in '!?.,;:':
                        if char == '!':
                            fila_pinyin.append('‚ùóÔ∏èEXCL')
                            fila_caracteres.append(f'„Äê{char}„Äë')
                        elif char == '?':
                            fila_pinyin.append('‚ùìPREG')
                            fila_caracteres.append(f'„Äê{char}„Äë')
                        elif char in '.,':
                            fila_pinyin.append(f'‚ö´{char}')
                            fila_caracteres.append(char)
                        else:
                            fila_pinyin.append(f'‚ó¶{char}‚ó¶')
                            fila_caracteres.append(char)
                    # Comillas y par√©ntesis (importantes para contexto)
                    elif char in '""''ÔºàÔºâ()[]{}„Äê„Äë„Ää„Äã':
                        fila_pinyin.append(f'üìù{char}')
                        fila_caracteres.append(char)
                    # Otros s√≠mbolos
                    elif char in '"\'"/<>-=+*&%$#@~`^|\\':
                        fila_pinyin.append(f'‚ó¶{char}‚ó¶')
                        fila_caracteres.append(char)
                    elif char == ' ':
                        fila_pinyin.append('‚ñ´Ô∏è')
                        fila_caracteres.append(char)
                    elif char.isdigit():
                        fila_pinyin.append(f'üî¢{char}')
                        fila_caracteres.append(char)
                    elif char.isalpha():
                        fila_pinyin.append(f'üî§{char}')
                        fila_caracteres.append(char)
                    else:
                        fila_pinyin.append(f'‚óä{char}‚óä')
                        fila_caracteres.append(char)
                
                if fila_pinyin:
                    datos.append(fila_pinyin)
                    datos.append(fila_caracteres)
            
            # Separador entre l√≠neas (optimizado)
            if idx_linea < len(lineas) - 1 and linea.strip():
                # L√≠nea separadora compacta
                separador = ['‚≠ê']
                if len(separador) < self.caracteres_por_linea:
                    separador.extend([''] * (self.caracteres_por_linea - len(separador)))
                datos.append(separador)
        
        return datos
    
    def deshabilitar_botones(self):
        """Deshabilita los botones durante la traducci√≥n"""
        botones = [self.btn_traducir, self.btn_auto, self.btn_espanol, self.btn_ingles]
        for btn in botones:
            if hasattr(btn, 'configure'):
                btn.configure(state="disabled")
    
    def habilitar_botones(self):
        """Habilita los botones despu√©s de la traducci√≥n"""
        botones = [self.btn_traducir, self.btn_auto, self.btn_espanol, self.btn_ingles]
        for btn in botones:
            if hasattr(btn, 'configure'):
                btn.configure(state="normal")
    
    def mostrar_progreso_traduccion(self, mensaje):
        """Muestra mensajes de progreso durante la traducci√≥n"""
        if hasattr(self, 'info_pinyin'):
            self.info_pinyin.configure(text=f"‚è≥ {mensaje}")
            self.app.update()  # Forzar actualizaci√≥n de la UI
    
    def traducir_a_ingles(self):
        """Traduce texto del chino al ingl√©s con barra de progreso y optimizaci√≥n"""
        texto = self.texto_entrada.get("1.0", "end-1c")
        if not texto.strip():
            self.mostrar_error("Por favor, ingresa texto en chino para traducir")
            return
        
        # Prevenir m√∫ltiples traducciones simult√°neas
        if self.traduccion_en_progreso:
            self.mostrar_error("Ya hay una traducci√≥n en progreso. Espera a que termine.")
            return
        
        # Deshabilitar botones durante traducci√≥n
        self.deshabilitar_botones()
        
        # Ejecutar traducci√≥n en hilo separado
        def traducir_hilo():
            try:
                self.traduccion_en_progreso = True
                self.app.after(0, lambda: self.mostrar_barra_progreso("Iniciando traducci√≥n a ingl√©s..."))
                
                # Verificar cach√© primero
                cache_key = f"en_{texto}"
                if cache_key in self.cache_traducciones:
                    self.app.after(0, lambda: self.actualizar_progreso(50, "Recuperando del cach√©..."))
                    texto_ingles = self.cache_traducciones[cache_key]
                    self.app.after(0, lambda: self.actualizar_progreso(80, "Cach√© recuperado"))
                else:
                    # Traducir texto optimizado
                    self.app.after(0, lambda: self.actualizar_progreso(20, "Analizando texto..."))
                    texto_ingles = self.traducir_texto_optimizado(texto, 'en')
                    # Guardar en cach√©
                    self.cache_traducciones[cache_key] = texto_ingles
                    self.app.after(0, lambda: self.actualizar_progreso(80, "Traducci√≥n completada"))
                
                # Mostrar traducci√≥n
                def mostrar_resultado():
                    self.texto_traduccion.delete("1.0", "end")
                    self.texto_traduccion.insert("1.0", texto_ingles)
                    # Guardar en variables para uso posterior
                    self.traduccion_actual = texto_ingles
                    self.texto_chino_actual = texto
                    self.actualizar_progreso(90, "Mostrando traducci√≥n...")
                
                self.app.after(0, mostrar_resultado)
                
                # Generar pinyin si es necesario
                if self.es_texto_chino(texto):
                    self.app.after(0, lambda: self.actualizar_progreso(95, "Generando tabla Pinyin..."))
                    self.app.after(0, lambda: self.generar_pinyin_optimizado(texto))
                
                # Completar
                self.app.after(0, lambda: self.actualizar_progreso(100, "¬°Traducci√≥n completada!"))
                time.sleep(0.5)  # Mostrar brevemente el 100%
                self.app.after(0, self.ocultar_barra_progreso)
                
            except Exception as e:
                self.app.after(0, lambda: self.mostrar_error(f"Error en la traducci√≥n: {str(e)}"))
                self.app.after(0, self.ocultar_barra_progreso)
            finally:
                self.traduccion_en_progreso = False
                self.app.after(0, self.habilitar_botones)
        
        # Ejecutar en hilo separado
        self.executor.submit(traducir_hilo)
    
    def traducir_texto_largo(self, texto, idioma_destino):
        """Traduce textos largos dividi√©ndolos en segmentos peque√±os preservando formato exacto"""
        try:
            # L√≠mite m√°s peque√±o para mejor precisi√≥n y respeto del formato
            limite_segmento = 1500  # Segmentos m√°s peque√±os para mejor control
            
            # Si el texto es muy corto, traducir directamente
            if len(texto) <= limite_segmento:
                if idioma_destino == 'es':
                    traductor = GoogleTranslator(source='zh-CN', target='es')
                else:  # 'en'
                    traductor = GoogleTranslator(source='zh-CN', target='en')
                return traductor.translate(texto)
            
            # Dividir por l√≠neas para preservar formato exacto
            lineas = texto.split('\n')
            lineas_traducidas = []
            
            for linea in lineas:
                if not linea.strip():  # L√≠nea vac√≠a
                    lineas_traducidas.append('')  # Preservar l√≠neas vac√≠as
                    continue
                
                # Si la l√≠nea es muy larga, dividirla por oraciones
                if len(linea) > limite_segmento:
                    # Dividir por puntuaciones para respetar el contexto
                    segmentos = self.dividir_linea_en_segmentos(linea, limite_segmento)
                    segmentos_traducidos = []
                    
                    for segmento in segmentos:
                        if segmento.strip():
                            try:
                                if idioma_destino == 'es':
                                    traductor = GoogleTranslator(source='zh-CN', target='es')
                                else:  # 'en'
                                    traductor = GoogleTranslator(source='zh-CN', target='en')
                                
                                segmento_traducido = traductor.translate(segmento.strip())
                                segmentos_traducidos.append(segmento_traducido)
                            except Exception as e:
                                print(f"Error traduciendo segmento: {e}")
                                segmentos_traducidos.append(segmento)  # Mantener original si falla
                    
                    # Unir segmentos de la l√≠nea
                    linea_completa = ' '.join(segmentos_traducidos)
                    lineas_traducidas.append(linea_completa)
                else:
                    # L√≠nea corta, traducir directamente
                    try:
                        if idioma_destino == 'es':
                            traductor = GoogleTranslator(source='zh-CN', target='es')
                        else:  # 'en'
                            traductor = GoogleTranslator(source='zh-CN', target='en')
                        
                        linea_traducida = traductor.translate(linea)
                        lineas_traducidas.append(linea_traducida)
                    except Exception as e:
                        print(f"Error traduciendo l√≠nea: {e}")
                        lineas_traducidas.append(linea)  # Mantener original si falla
            
            # Unir todas las l√≠neas preservando saltos de l√≠nea exactos
            return '\n'.join(lineas_traducidas)
            
        except Exception as e:
            raise Exception(f"Error en traducci√≥n por segmentos: {str(e)}")
    
    def dividir_linea_en_segmentos(self, linea, limite):
        """Divide una l√≠nea larga en segmentos respetando puntuaciones importantes (versi√≥n mejorada)"""
        if len(linea) <= limite:
            return [linea]
        
        segmentos = []
        segmento_actual = ""
        
        # Puntuaciones que indican fin de oraci√≥n o pausa (mejoradas)
        puntuaciones_corte = ['„ÄÇ', 'ÔºÅ', 'Ôºü', 'Ôºõ', '.', '!', '?', ';', '‚Ä¶', '‚Äî‚Äî']
        puntuaciones_pausa = ['Ôºå', '„ÄÅ', ',', ':', 'Ôºö', 'Ôºà', 'Ôºâ', '(', ')', '"', '"', ''', ''']
        puntuaciones_enfasis = ['ÔºÅ', 'Ôºü', '!', '?']  # Requieren tratamiento especial
        
        i = 0
        while i < len(linea):
            char = linea[i]
            segmento_actual += char
            
            # Si alcanzamos el l√≠mite, buscar un punto de corte apropiado
            if len(segmento_actual) >= limite:
                # Buscar punto de corte hacia atr√°s
                punto_corte = -1
                
                # Primero buscar puntuaciones de corte (prioridad a exclamaci√≥n y pregunta)
                for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 200), -1):
                    if segmento_actual[j] in puntuaciones_corte:
                        punto_corte = j + 1
                        # Si es puntuaci√≥n de √©nfasis, incluir posibles espacios despu√©s
                        if segmento_actual[j] in puntuaciones_enfasis:
                            k = j + 1
                            while k < len(segmento_actual) and segmento_actual[k] in ' \n\t':
                                k += 1
                            punto_corte = k
                        break
                
                # Si no encontramos puntuaci√≥n de corte, buscar puntuaci√≥n de pausa
                if punto_corte == -1:
                    for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 100), -1):
                        if segmento_actual[j] in puntuaciones_pausa:
                            punto_corte = j + 1
                            break
                
                # Si no encontramos nada, cortar en espacio
                if punto_corte == -1:
                    for j in range(len(segmento_actual) - 1, max(0, len(segmento_actual) - 50), -1):
                        if segmento_actual[j] == ' ':
                            punto_corte = j + 1
                            break
                
                # Si a√∫n no encontramos, cortar forzosamente
                if punto_corte == -1:
                    punto_corte = limite
                
                # Agregar segmento y continuar
                segmentos.append(segmento_actual[:punto_corte])
                segmento_actual = segmento_actual[punto_corte:]
                # No incrementar i porque ya avanzamos en segmento_actual
                continue
            
            i += 1
        
        # Agregar el √∫ltimo segmento si queda algo
        if segmento_actual.strip():
            segmentos.append(segmento_actual)
        
        return segmentos
    
    def generar_pinyin(self, texto_chino):
        """Genera pinyin usando CTkTable con formato responsive optimizado, cach√© y sin l√≠mites"""
        try:
            if not texto_chino.strip():
                return
            
            # Verificar cach√© de pinyin
            if texto_chino in self.cache_pinyin:
                datos_tabla = self.cache_pinyin[texto_chino]
                self.crear_tabla_pinyin(datos_tabla)
                return
            
            # Asegurar que tenemos la configuraci√≥n responsive
            if not hasattr(self, 'caracteres_por_linea'):
                self.ejecutar_ajuste_responsive()
            
            # Procesar texto completo incluyendo puntuaciones y espacios
            # Ya no limitamos a solo caracteres chinos - procesamos todo
            if not self.contiene_caracteres_chinos(texto_chino):
                self.mostrar_error_pinyin("No se encontraron caracteres chinos v√°lidos para generar Pinyin")
                return
            
            # Crear datos para la tabla sin l√≠mites de caracteres
            datos_tabla = self.crear_datos_tabla_pinyin_completo(texto_chino)
            
            # Guardar en cach√©
            self.cache_pinyin[texto_chino] = datos_tabla
            
            # Crear o actualizar la tabla
            self.crear_tabla_pinyin(datos_tabla)
            
            # Mostrar informaci√≥n sobre caracteres procesados
            total_chars = len([c for c in texto_chino if '\u4e00' <= c <= '\u9fff'])
            if hasattr(self, 'info_pinyin') and total_chars > 50:
                mensaje_info = f"üí° {total_chars} caracteres chinos procesados ‚Ä¢ Texto completo con puntuaciones"
                self.info_pinyin.configure(text=mensaje_info)
            
        except Exception as e:
            print(f"Error completo en generar_pinyin: {e}")
            self.mostrar_error_pinyin(f"Error generando Pinyin: {str(e)}")
    
    def contiene_caracteres_chinos(self, texto):
        """Verifica si el texto contiene al menos un car√°cter chino"""
        for char in texto:
            if '\u4e00' <= char <= '\u9fff':
                return True
        return False
    
    def crear_datos_tabla_pinyin_completo(self, texto_completo):
        """Crea los datos para la tabla de pinyin preservando puntuaciones, espacios y saltos de l√≠nea con mejor visualizaci√≥n"""
        if not hasattr(self, 'caracteres_por_linea'):
            self.caracteres_por_linea = 6
        
        # Ajustar caracteres por l√≠nea basado en cantidad de caracteres chinos
        total_chars_chinos = len([c for c in texto_completo if '\u4e00' <= c <= '\u9fff'])
        if total_chars_chinos > 150:
            self.caracteres_por_linea = 10  # M√°s caracteres para textos muy largos
        elif total_chars_chinos > 100:
            self.caracteres_por_linea = 8
        elif total_chars_chinos > 50:
            self.caracteres_por_linea = 7
        else:
            self.caracteres_por_linea = 6
            
        datos = []
        
        # Dividir por l√≠neas para preservar saltos de l√≠nea
        lineas = texto_completo.split('\n')
        
        for idx_linea, linea in enumerate(lineas):
            if not linea.strip():  # L√≠nea vac√≠a
                # Agregar fila vac√≠a m√°s visible para preservar espaciado
                datos.append(['‚îà' * self.caracteres_por_linea])  # L√≠nea punteada para espacios
                continue
            
            # Procesar l√≠nea car√°cter por car√°cter respetando todo
            caracteres_linea = list(linea)
            
            # Procesar en grupos
            for i in range(0, len(caracteres_linea), self.caracteres_por_linea):
                grupo = caracteres_linea[i:i + self.caracteres_por_linea]
                
                # Fila de pinyin (pronunciaci√≥n)
                fila_pinyin = []
                # Fila de caracteres originales
                fila_caracteres = []
                
                for char in grupo:
                    if '\u4e00' <= char <= '\u9fff':  # Es un car√°cter chino
                        try:
                            # Generar pinyin con tonos
                            pinyin_result = pinyin(char, style=Style.TONE, heteronym=False)
                            if pinyin_result and pinyin_result[0]:
                                pinyin_char = pinyin_result[0][0]
                            else:
                                # Fallback: sin tonos
                                pinyin_result = lazy_pinyin(char)
                                pinyin_char = pinyin_result[0] if pinyin_result else "?"
                            
                            pinyin_char = pinyin_char.strip()
                            fila_pinyin.append(pinyin_char)
                            
                        except Exception as e:
                            print(f"Error procesando car√°cter '{char}': {e}")
                            fila_pinyin.append("?")
                    
                    elif char in 'Ôºå„ÄÇÔºÅÔºüÔºõÔºö""''ÔºàÔºâ„Äê„Äë„Ää„Äã„ÄÅ':  # Puntuaciones chinas
                        fila_pinyin.append(f'‚Ä¢{char}‚Ä¢')  # Destacar puntuaciones chinas
                    elif char in ',.!?;:"\'"()[]{}/<>-=+*&%$#@~`^|\\':  # Puntuaciones occidentales
                        fila_pinyin.append(f'‚ó¶{char}‚ó¶')  # Destacar puntuaciones occidentales
                    elif char == ' ':  # Espacio
                        fila_pinyin.append('‚ñ´')  # Cuadro peque√±o para espacios
                    elif char.isdigit():  # N√∫meros
                        fila_pinyin.append(f'#{char}')  # Destacar n√∫meros
                    elif char.isalpha():  # Letras occidentales
                        fila_pinyin.append(f'[{char}]')  # Corchetes para letras
                    else:  # Otros caracteres especiales
                        fila_pinyin.append(f'‚óä{char}‚óä')  # Rombo para caracteres especiales
                    
                    # Agregar car√°cter original con formato
                    if '\u4e00' <= char <= '\u9fff':
                        fila_caracteres.append(f' {char} ')  # Espacios para caracteres chinos
                    else:
                        fila_caracteres.append(char)  # Sin espacios adicionales para otros
                
                # Agregar las filas si tienen contenido
                if fila_pinyin:
                    datos.append(fila_pinyin)
                    datos.append(fila_caracteres)
            
            # Agregar separador visual entre l√≠neas (excepto la √∫ltima)
            if idx_linea < len(lineas) - 1 and linea.strip():
                # L√≠nea separadora m√°s visible
                # L√≠nea separadora m√°s compacta
                separador = ['‚≠ê']
                if len(separador) < self.caracteres_por_linea:
                    separador.extend([''] * (self.caracteres_por_linea - len(separador)))
                datos.append(separador)
        
        return datos
    
    def mostrar_advertencia_limite(self, total_caracteres, limite):
        """Muestra advertencia cuando el texto excede el l√≠mite recomendado"""
        mensaje = (f"‚ö†Ô∏è Texto muy largo ({total_caracteres} caracteres)\n"
                  f"Se procesar√°n los primeros {limite} caracteres para mejor rendimiento.\n"
                  f"Para textos muy largos, considera dividirlos en secciones.")
        
        # Mostrar en el √°rea de informaci√≥n temporalmente
        if hasattr(self, 'info_pinyin'):
            texto_original = self.info_pinyin.cget("text")
            self.info_pinyin.configure(text=mensaje)
            # Restaurar el texto despu√©s de 3 segundos
            self.app.after(3000, lambda: self.info_pinyin.configure(text=texto_original))
    
    def crear_datos_tabla_pinyin(self, texto_limpio):
        """Crea los datos para la tabla de pinyin de forma continua"""
        if not hasattr(self, 'caracteres_por_linea'):
            self.caracteres_por_linea = 6
        
        # Ajustar caracteres por l√≠nea basado en cantidad total para mejor visualizaci√≥n
        total_chars = len(texto_limpio)
        if total_chars > 100:
            self.caracteres_por_linea = 10  # M√°s caracteres por l√≠nea para textos largos
        elif total_chars > 50:
            self.caracteres_por_linea = 8
        else:
            self.caracteres_por_linea = 6
            
        datos = []
        
        # Procesar caracteres en grupos sin separadores
        for i in range(0, len(texto_limpio), self.caracteres_por_linea):
            grupo = texto_limpio[i:i + self.caracteres_por_linea]
            
            # Fila de pinyin (pronunciaci√≥n)
            fila_pinyin = []
            # Fila de caracteres (destacada)
            fila_caracteres = []
            
            for char in grupo:
                try:
                    # Usar pypinyin correctamente - primero con tonos diacr√≠ticos
                    pinyin_result = pinyin(char, style=Style.TONE, heteronym=False)
                    if pinyin_result and pinyin_result[0]:
                        pinyin_char = pinyin_result[0][0]
                    else:
                        # Fallback: sin tonos
                        pinyin_result = lazy_pinyin(char)
                        pinyin_char = pinyin_result[0] if pinyin_result else "?"
                    
                    # Limpiar el resultado
                    pinyin_char = pinyin_char.strip()
                    fila_pinyin.append(pinyin_char)
                    # Caracteres con espacios para destacar
                    fila_caracteres.append(f" {char} ")
                    
                except Exception as e:
                    print(f"Error procesando car√°cter '{char}': {e}")
                    # Fallback: intentar m√©todo m√°s simple
                    try:
                        pinyin_simple = lazy_pinyin(char)
                        if pinyin_simple:
                            fila_pinyin.append(pinyin_simple[0])
                        else:
                            fila_pinyin.append("?")
                    except:
                        fila_pinyin.append("?")
                    fila_caracteres.append(f" {char} ")
            
            # Agregar las filas directamente sin separadores
            datos.append(fila_pinyin)
            datos.append(fila_caracteres)
        
        return datos
    
    def crear_tabla_pinyin(self, datos):
        """Crea la tabla CTk optimizada con scroll elegante y letras m√°s grandes"""
        try:
            # Solo proceder si hay datos v√°lidos
            if not datos:
                return
            
            # Destruir tabla anterior eficientemente
            if hasattr(self, 'tabla_pinyin') and self.tabla_pinyin:
                self.tabla_pinyin.destroy()
                self.tabla_pinyin = None
            
            # Ocultar texto de informaci√≥n
            self.texto_info.grid_remove()
            
            # Calcular dimensiones una sola vez
            filas = len(datos)
            columnas = len(datos[0]) if datos else 1
            
            # Tama√±os optimizados con letras m√°s grandes
            if filas > 20:  # Para textos muy largos
                ancho_celda, alto_celda, font_size = 100, 45, 14  # M√°s grande
            elif self.ventana_ancho < 900:
                ancho_celda, alto_celda, font_size = 110, 50, 16  # M√°s grande
            elif self.ventana_ancho < 1300:
                ancho_celda, alto_celda, font_size = 130, 55, 18  # M√°s grande
            else:
                ancho_celda, alto_celda, font_size = 150, 60, 20  # M√°s grande
            
            # Crear tabla dentro del frame scrollable con letras m√°s grandes
            self.tabla_pinyin = CTkTable(
                master=self.scrollable_frame,
                row=filas,
                column=columnas,
                values=datos,
                corner_radius=6,  # Esquinas m√°s redondeadas
                header_color=("#2563eb", "#1d4ed8"),
                colors=[("#f8fafc", "#1e293b"), ("#ffffff", "#111827")],
                font=("Arial", font_size, "bold"),  # Fuente m√°s grande
                text_color=("#0f172a", "#f8fafc"),
                width=ancho_celda,
                height=alto_celda
            )
            
            # Posicionar la tabla en el frame scrollable
            self.tabla_pinyin.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
            
            # Configurar el scrollable frame para que se expanda con la tabla
            self.scrollable_frame.grid_columnconfigure(0, weight=1)
            
            # Agregar informaci√≥n sobre la cantidad de caracteres procesados
            total_caracteres = sum(len([c for c in fila if c.strip()]) for i, fila in enumerate(datos) if i % 2 == 1)
            if hasattr(self, 'info_pinyin') and total_caracteres > 50:
                # Mensaje informativo mejorado
                mensaje_info = f"üí° {total_caracteres} caracteres procesados ‚Ä¢ Usa scroll para navegar"
                self.info_pinyin.configure(text=mensaje_info)
            
        except Exception as e:
            print(f"Error creando tabla: {e}")
            self.mostrar_error_pinyin(f"Error: {str(e)}")
    
    def mostrar_error_pinyin(self, mensaje):
        """Muestra errores en el √°rea de pinyin de forma eficiente"""
        # Limpiar tabla si existe
        if hasattr(self, 'tabla_pinyin') and self.tabla_pinyin:
            self.tabla_pinyin.destroy()
            self.tabla_pinyin = None
        
        # Mostrar error en texto de informaci√≥n en el frame scrollable
        self.texto_info.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.texto_info.delete("1.0", "end")
        self.texto_info.insert("1.0", f"‚ùå {mensaje}")
    
    def limpiar_pinyin(self):
        """Limpia el √°rea de pinyin"""
        if hasattr(self, 'tabla_pinyin') and self.tabla_pinyin:
            self.tabla_pinyin.destroy()
            self.tabla_pinyin = None
        
        # Mostrar mensaje inicial en el frame scrollable
        self.texto_info.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.mostrar_mensaje_inicial()
    
    def limpiar_campos(self):
        """Limpia todos los campos y cach√© de manera optimizada"""
        try:
            # Limpiar UI
            self.texto_entrada.delete("1.0", "end")
            self.texto_traduccion.delete("1.0", "end")
            self.limpiar_pinyin()
            
            # Limpiar variables de cach√©
            self.traduccion_actual = ""
            self.pinyin_actual = ""
            self.texto_chino_actual = ""
            
            # Resetear referencia de √∫ltima tabla
            if hasattr(self, 'ultima_tabla_datos'):
                self.ultima_tabla_datos = None
            
            # Ocultar barra de progreso si est√° visible
            if hasattr(self, 'frame_progreso'):
                self.ocultar_barra_progreso()
            
            # Enfocar el campo de entrada
            self.texto_entrada.focus_set()
            
            print("Campos limpiados correctamente con optimizaci√≥n")
            
        except Exception as e:
            print(f"Error limpiando campos: {e}")
            # Fallback b√°sico
            self.texto_entrada.delete("1.0", "end")
            self.texto_traduccion.delete("1.0", "end")
            self.limpiar_pinyin()
            self.texto_entrada.focus_set()
    
    def es_texto_chino(self, texto):
        """Verifica si el texto contiene caracteres chinos"""
        for char in texto:
            if '\u4e00' <= char <= '\u9fff':
                return True
        return False
    
    def mostrar_error(self, mensaje):
        """Muestra un mensaje de error en una ventana emergente responsive"""
        try:
            ventana_error = customtkinter.CTkToplevel(self.app)
            
            # Tama√±o responsive para la ventana de error
            if self.ventana_ancho < 600:
                ventana_error.geometry("300x120")
            else:
                ventana_error.geometry("400x150")
                
            ventana_error.title("Error")
            ventana_error.resizable(False, False)
            
            # Centrar la ventana
            ventana_error.transient(self.app)
            ventana_error.grab_set()
            
            # Configurar grid
            ventana_error.grid_columnconfigure(0, weight=1)
            
            label_error = customtkinter.CTkLabel(
                ventana_error,
                text=mensaje,
                font=("Arial", 12),
                wraplength=350 if self.ventana_ancho >= 600 else 250
            )
            label_error.grid(row=0, column=0, pady=20, padx=20)
            
            btn_ok = customtkinter.CTkButton(
                ventana_error,
                text="OK",
                command=ventana_error.destroy,
                width=80,
                height=30
            )
            btn_ok.grid(row=1, column=0, pady=(0, 20))
            
            # Centrar la ventana en la pantalla
            ventana_error.update_idletasks()
            x = (ventana_error.winfo_screenwidth() // 2) - (ventana_error.winfo_width() // 2)
            y = (ventana_error.winfo_screenheight() // 2) - (ventana_error.winfo_height() // 2)
            ventana_error.geometry(f"+{x}+{y}")
            
        except Exception as e:
            print(f"Error mostrando mensaje: {e}")
    
    def on_window_resize(self, event):
        """Maneja redimensionamiento eficientemente"""
        # Solo procesar eventos de ventana principal
        if event.widget == self.app:
            # Cancelar timer anterior
            if hasattr(self, '_resize_timer'):
                self.app.after_cancel(self._resize_timer)
            
            # Delay m√°s largo para menos llamadas
            self._resize_timer = self.app.after(200, self.ejecutar_ajuste_responsive)
    
    def ejecutar(self):
        """Inicia la aplicaci√≥n con configuraci√≥n inicial optimizada"""
        try:
            # Configuraci√≥n inicial
            self.ejecutar_ajuste_responsive()
            
            # Configurar cierre limpio
            self.app.protocol("WM_DELETE_WINDOW", self.cerrar_aplicacion)
            
            # El mensaje de bienvenida ya se muestra en mostrar_mensaje_inicial()
            
            # Iniciar la aplicaci√≥n
            self.app.mainloop()
        except KeyboardInterrupt:
            print("Aplicaci√≥n cerrada por el usuario")
        except Exception as e:
            print(f"Error ejecutando la aplicaci√≥n: {e}")
            # Mostrar error en consola para debugging
            import traceback
            traceback.print_exc()
    
    def validar_respeto_puntuaciones(self, texto_original, texto_procesado):
        """Valida que las puntuaciones importantes se respeten en el procesamiento"""
        try:
            # Contar puntuaciones importantes en el texto original
            puntuaciones_importantes = ['!', '?', 'ÔºÅ', 'Ôºü', '.', '„ÄÇ', ';', 'Ôºõ', ':', 'Ôºö']
            
            contador_original = {}
            contador_procesado = {}
            
            for punct in puntuaciones_importantes:
                contador_original[punct] = texto_original.count(punct)
                contador_procesado[punct] = texto_procesado.count(punct)
            
            # Verificar que no se hayan perdido puntuaciones
            perdidas = []
            for punct, count_orig in contador_original.items():
                count_proc = contador_procesado.get(punct, 0)
                if count_proc < count_orig:
                    perdidas.append(f"{punct}: {count_orig} ‚Üí {count_proc}")
            
            if perdidas:
                print(f"‚ö†Ô∏è Puntuaciones perdidas: {', '.join(perdidas)}")
                return False
            else:
                print("‚úÖ Todas las puntuaciones importantes fueron respetadas")
                return True
                
        except Exception as e:
            print(f"Error validando puntuaciones: {e}")
            return False
    
    def probar_respeto_puntuaciones(self):
        """M√©todo de prueba para verificar el respeto de puntuaciones"""
        textos_prueba = [
            "¬°Hola! ¬øC√≥mo est√°s? Espero que bien; todo est√° perfecto.",
            "‰Ω†Â•ΩÔºÅ‰Ω†Â•ΩÂêóÔºüÊàëÂæàÂ•ΩÔºõË∞¢Ë∞¢‰Ω†ÁöÑÂÖ≥ÂøÉ„ÄÇ",
            "What?! Are you serious? This is amazing!",
            "„Åì„Çå„ÅØÁ¥†Êô¥„Çâ„Åó„ÅÑÔºÅÊú¨ÂΩì„Åß„Åô„ÅãÔºü‰ø°„Åò„Çâ„Çå„Åæ„Åõ„Çì‚Ä¶"
        ]
        
        print("üîç Probando respeto de puntuaciones importantes...")
        
        for i, texto in enumerate(textos_prueba, 1):
            print(f"\n--- Prueba {i} ---")
            print(f"Texto original: {texto}")
            
            # Probar divisi√≥n en segmentos
            if self.contiene_caracteres_chinos(texto):
                segmentos = self.dividir_linea_en_segmentos(texto, 20)
            else:
                segmentos = self.dividir_linea_en_segmentos_occidentales(texto, 20)
            
            texto_reunido = ''.join(segmentos)
            print(f"Texto procesado: {texto_reunido}")
            
            # Validar
            respetado = self.validar_respeto_puntuaciones(texto, texto_reunido)
            print(f"Resultado: {'‚úÖ CORRECTO' if respetado else '‚ùå ERROR'}")
        
        print("\nüéØ Prueba de respeto de puntuaciones completada.")
    
    def cerrar_aplicacion(self):
        """Cierra la aplicaci√≥n de manera limpia"""
        try:
            # Cancelar traducciones en progreso
            if self.traduccion_en_progreso:
                self.traduccion_en_progreso = False
            
            # Cerrar el pool de hilos
            if hasattr(self, 'executor'):
                self.executor.shutdown(wait=False)
            
            # Cerrar la aplicaci√≥n
            self.app.destroy()
        except Exception as e:
            print(f"Error cerrando aplicaci√≥n: {e}")
            self.app.destroy()


# --- Punto de entrada principal ---
if __name__ == "__main__":
    try:
        traductor = TraductorChino()
        traductor.ejecutar()
    except Exception as e:
        print(f"Error iniciando la aplicaci√≥n: {e}")
        input("Presiona Enter para salir...")